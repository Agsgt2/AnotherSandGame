1: precision highp float;
2: precision highp int;
3: #define HIGH_PRECISION
4: #define SHADER_NAME MeshLambertMaterial
5: #define GAMMA_FACTOR 2
6: uniform mat4 viewMatrix;
7: uniform vec3 cameraPosition;
8: uniform bool isOrthographic;
9: #define TONE_MAPPING
10: #ifndef saturate
11: #define saturate(a) clamp( a, 0.0, 1.0 )
12: #endif
13: uniform float toneMappingExposure;
14: uniform float toneMappingWhitePoint;
15: vec3 LinearToneMapping( vec3 color ) {
16: 	return toneMappingExposure * color;
17: }
18: vec3 ReinhardToneMapping( vec3 color ) {
19: 	color *= toneMappingExposure;
20: 	return saturate( color / ( vec3( 1.0 ) + color ) );
21: }
22: #define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
23: vec3 Uncharted2ToneMapping( vec3 color ) {
24: 	color *= toneMappingExposure;
25: 	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );
26: }
27: vec3 OptimizedCineonToneMapping( vec3 color ) {
28: 	color *= toneMappingExposure;
29: 	color = max( vec3( 0.0 ), color - 0.004 );
30: 	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
31: }
32: vec3 ACESFilmicToneMapping( vec3 color ) {
33: 	color *= toneMappingExposure;
34: 	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );
35: }
36: vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }
37: 
38: vec4 LinearToLinear( in vec4 value ) {
39: 	return value;
40: }
41: vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
42: 	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
43: }
44: vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
45: 	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
46: }
47: vec4 sRGBToLinear( in vec4 value ) {
48: 	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
49: }
50: vec4 LinearTosRGB( in vec4 value ) {
51: 	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
52: }
53: vec4 RGBEToLinear( in vec4 value ) {
54: 	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
55: }
56: vec4 LinearToRGBE( in vec4 value ) {
57: 	float maxComponent = max( max( value.r, value.g ), value.b );
58: 	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
59: 	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
60: }
61: vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
62: 	return vec4( value.rgb * value.a * maxRange, 1.0 );
63: }
64: vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
65: 	float maxRGB = max( value.r, max( value.g, value.b ) );
66: 	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
67: 	M = ceil( M * 255.0 ) / 255.0;
68: 	return vec4( value.rgb / ( M * maxRange ), M );
69: }
70: vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
71: 	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
72: }
73: vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
74: 	float maxRGB = max( value.r, max( value.g, value.b ) );
75: 	float D = max( maxRange / maxRGB, 1.0 );
76: 	D = min( floor( D ) / 255.0, 1.0 );
77: 	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
78: }
79: const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
80: vec4 LinearToLogLuv( in vec4 value )  {
81: 	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
82: 	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
83: 	vec4 vResult;
84: 	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
85: 	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
86: 	vResult.w = fract( Le );
87: 	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
88: 	return vResult;
89: }
90: const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
91: vec4 LogLuvToLinear( in vec4 value ) {
92: 	float Le = value.z * 255.0 + value.w;
93: 	vec3 Xp_Y_XYZp;
94: 	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
95: 	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
96: 	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
97: 	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
98: 	return vec4( max( vRGB, 0.0 ), 1.0 );
99: }
100: vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
101: vec4 matcapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
102: vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
103: vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }
104: vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }
105: 
106: 
107: 				varying vec4 vInstanceColor;
108: 				varying vec3 vInstanceEmissive;
109: 			ERRORRRuniform vec3 diffuse;
110: uniform vec3 emissive;
111: uniform float opacity;
112: varying vec3 vLightFront;
113: varying vec3 vIndirectFront;
114: #ifdef DOUBLE_SIDED
115: 	varying vec3 vLightBack;
116: 	varying vec3 vIndirectBack;
117: #endif
118: #define PI 3.14159265359
119: #define PI2 6.28318530718
120: #define PI_HALF 1.5707963267949
121: #define RECIPROCAL_PI 0.31830988618
122: #define RECIPROCAL_PI2 0.15915494
123: #define LOG2 1.442695
124: #define EPSILON 1e-6
125: #ifndef saturate
126: #define saturate(a) clamp( a, 0.0, 1.0 )
127: #endif
128: #define whiteComplement(a) ( 1.0 - saturate( a ) )
129: float pow2( const in float x ) { return x*x; }
130: float pow3( const in float x ) { return x*x*x; }
131: float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
132: float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
133: highp float rand( const in vec2 uv ) {
134: 	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
135: 	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
136: 	return fract(sin(sn) * c);
137: }
138: #ifdef HIGH_PRECISION
139: 	float precisionSafeLength( vec3 v ) { return length( v ); }
140: #else
141: 	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
142: 	float precisionSafeLength( vec3 v ) {
143: 		float maxComponent = max3( abs( v ) );
144: 		return length( v / maxComponent ) * maxComponent;
145: 	}
146: #endif
147: struct IncidentLight {
148: 	vec3 color;
149: 	vec3 direction;
150: 	bool visible;
151: };
152: struct ReflectedLight {
153: 	vec3 directDiffuse;
154: 	vec3 directSpecular;
155: 	vec3 indirectDiffuse;
156: 	vec3 indirectSpecular;
157: };
158: struct GeometricContext {
159: 	vec3 position;
160: 	vec3 normal;
161: 	vec3 viewDir;
162: #ifdef CLEARCOAT
163: 	vec3 clearcoatNormal;
164: #endif
165: };
166: vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
167: 	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
168: }
169: vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
170: 	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
171: }
172: vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
173: 	float distance = dot( planeNormal, point - pointOnPlane );
174: 	return - distance * planeNormal + point;
175: }
176: float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
177: 	return sign( dot( point - pointOnPlane, planeNormal ) );
178: }
179: vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
180: 	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
181: }
182: mat3 transposeMat3( const in mat3 m ) {
183: 	mat3 tmp;
184: 	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
185: 	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
186: 	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
187: 	return tmp;
188: }
189: float linearToRelativeLuminance( const in vec3 color ) {
190: 	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
191: 	return dot( weights, color.rgb );
192: }
193: bool isPerspectiveMatrix( mat4 m ) {
194:   return m[ 2 ][ 3 ] == - 1.0;
195: }
196: vec3 packNormalToRGB( const in vec3 normal ) {
197: 	return normalize( normal ) * 0.5 + 0.5;
198: }
199: vec3 unpackRGBToNormal( const in vec3 rgb ) {
200: 	return 2.0 * rgb.xyz - 1.0;
201: }
202: const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
203: const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
204: const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
205: const float ShiftRight8 = 1. / 256.;
206: vec4 packDepthToRGBA( const in float v ) {
207: 	vec4 r = vec4( fract( v * PackFactors ), v );
208: 	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
209: }
210: float unpackRGBAToDepth( const in vec4 v ) {
211: 	return dot( v, UnpackFactors );
212: }
213: vec4 encodeHalfRGBA ( vec2 v ) {
214: 	vec4 encoded = vec4( 0.0 );
215: 	const vec2 offset = vec2( 1.0 / 255.0, 0.0 );
216: 	encoded.xy = vec2( v.x, fract( v.x * 255.0 ) );
217: 	encoded.xy = encoded.xy - ( encoded.yy * offset );
218: 	encoded.zw = vec2( v.y, fract( v.y * 255.0 ) );
219: 	encoded.zw = encoded.zw - ( encoded.ww * offset );
220: 	return encoded;
221: }
222: vec2 decodeHalfRGBA( vec4 v ) {
223: 	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
224: }
225: float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
226: 	return ( viewZ + near ) / ( near - far );
227: }
228: float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
229: 	return linearClipZ * ( near - far ) - near;
230: }
231: float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
232: 	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
233: }
234: float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
235: 	return ( near * far ) / ( ( far - near ) * invClipZ - far );
236: }
237: #ifdef DITHERING
238: 	vec3 dithering( vec3 color ) {
239: 		float grid_position = rand( gl_FragCoord.xy );
240: 		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
241: 		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
242: 		return color + dither_shift_RGB;
243: 	}
244: #endif
245: #ifdef USE_COLOR
246: 	varying vec3 vColor;
247: #endif
248: #if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
249: 	varying vec2 vUv;
250: #endif
251: #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
252: 	varying vec2 vUv2;
253: #endif
254: #ifdef USE_MAP
255: 	uniform sampler2D map;
256: #endif
257: #ifdef USE_ALPHAMAP
258: 	uniform sampler2D alphaMap;
259: #endif
260: #ifdef USE_AOMAP
261: 	uniform sampler2D aoMap;
262: 	uniform float aoMapIntensity;
263: #endif
264: #ifdef USE_LIGHTMAP
265: 	uniform sampler2D lightMap;
266: 	uniform float lightMapIntensity;
267: #endif
268: #ifdef USE_EMISSIVEMAP
269: 	uniform sampler2D emissiveMap;
270: #endif
271: #ifdef USE_ENVMAP
272: 	uniform float envMapIntensity;
273: 	uniform float flipEnvMap;
274: 	uniform int maxMipLevel;
275: 	#ifdef ENVMAP_TYPE_CUBE
276: 		uniform samplerCube envMap;
277: 	#else
278: 		uniform sampler2D envMap;
279: 	#endif
280: 	
281: #endif
282: #ifdef USE_ENVMAP
283: 	uniform float reflectivity;
284: 	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
285: 		#define ENV_WORLDPOS
286: 	#endif
287: 	#ifdef ENV_WORLDPOS
288: 		varying vec3 vWorldPosition;
289: 		uniform float refractionRatio;
290: 	#else
291: 		varying vec3 vReflect;
292: 	#endif
293: #endif
294: vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
295: 	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
296: 	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
297: 	vec4 r = roughness * c0 + c1;
298: 	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
299: 	return vec2( -1.04, 1.04 ) * a004 + r.zw;
300: }
301: float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
302: #if defined ( PHYSICALLY_CORRECT_LIGHTS )
303: 	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
304: 	if( cutoffDistance > 0.0 ) {
305: 		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
306: 	}
307: 	return distanceFalloff;
308: #else
309: 	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
310: 		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
311: 	}
312: 	return 1.0;
313: #endif
314: }
315: vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
316: 	return RECIPROCAL_PI * diffuseColor;
317: }
318: vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
319: 	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
320: 	return ( 1.0 - specularColor ) * fresnel + specularColor;
321: }
322: vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
323: 	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
324: 	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
325: 	return Fr * fresnel + F0;
326: }
327: float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
328: 	float a2 = pow2( alpha );
329: 	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
330: 	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
331: 	return 1.0 / ( gl * gv );
332: }
333: float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
334: 	float a2 = pow2( alpha );
335: 	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
336: 	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
337: 	return 0.5 / max( gv + gl, EPSILON );
338: }
339: float D_GGX( const in float alpha, const in float dotNH ) {
340: 	float a2 = pow2( alpha );
341: 	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
342: 	return RECIPROCAL_PI * a2 / pow2( denom );
343: }
344: vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
345: 	float alpha = pow2( roughness );
346: 	vec3 halfDir = normalize( incidentLight.direction + viewDir );
347: 	float dotNL = saturate( dot( normal, incidentLight.direction ) );
348: 	float dotNV = saturate( dot( normal, viewDir ) );
349: 	float dotNH = saturate( dot( normal, halfDir ) );
350: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
351: 	vec3 F = F_Schlick( specularColor, dotLH );
352: 	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
353: 	float D = D_GGX( alpha, dotNH );
354: 	return F * ( G * D );
355: }
356: vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
357: 	const float LUT_SIZE  = 64.0;
358: 	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
359: 	const float LUT_BIAS  = 0.5 / LUT_SIZE;
360: 	float dotNV = saturate( dot( N, V ) );
361: 	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
362: 	uv = uv * LUT_SCALE + LUT_BIAS;
363: 	return uv;
364: }
365: float LTC_ClippedSphereFormFactor( const in vec3 f ) {
366: 	float l = length( f );
367: 	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
368: }
369: vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
370: 	float x = dot( v1, v2 );
371: 	float y = abs( x );
372: 	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
373: 	float b = 3.4175940 + ( 4.1616724 + y ) * y;
374: 	float v = a / b;
375: 	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
376: 	return cross( v1, v2 ) * theta_sintheta;
377: }
378: vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
379: 	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
380: 	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
381: 	vec3 lightNormal = cross( v1, v2 );
382: 	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
383: 	vec3 T1, T2;
384: 	T1 = normalize( V - N * dot( V, N ) );
385: 	T2 = - cross( N, T1 );
386: 	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
387: 	vec3 coords[ 4 ];
388: 	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
389: 	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
390: 	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
391: 	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
392: 	coords[ 0 ] = normalize( coords[ 0 ] );
393: 	coords[ 1 ] = normalize( coords[ 1 ] );
394: 	coords[ 2 ] = normalize( coords[ 2 ] );
395: 	coords[ 3 ] = normalize( coords[ 3 ] );
396: 	vec3 vectorFormFactor = vec3( 0.0 );
397: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
398: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
399: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
400: 	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
401: 	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
402: 	return vec3( result );
403: }
404: vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
405: 	float dotNV = saturate( dot( normal, viewDir ) );
406: 	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
407: 	return specularColor * brdf.x + brdf.y;
408: }
409: void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
410: 	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
411: 	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
412: 	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
413: 	vec3 FssEss = F * brdf.x + brdf.y;
414: 	float Ess = brdf.x + brdf.y;
415: 	float Ems = 1.0 - Ess;
416: 	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
417: 	singleScatter += FssEss;
418: 	multiScatter += Fms * Ems;
419: }
420: float G_BlinnPhong_Implicit( ) {
421: 	return 0.25;
422: }
423: float D_BlinnPhong( const in float shininess, const in float dotNH ) {
424: 	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
425: }
426: vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
427: 	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
428: 	float dotNH = saturate( dot( geometry.normal, halfDir ) );
429: 	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
430: 	vec3 F = F_Schlick( specularColor, dotLH );
431: 	float G = G_BlinnPhong_Implicit( );
432: 	float D = D_BlinnPhong( shininess, dotNH );
433: 	return F * ( G * D );
434: }
435: float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
436: 	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
437: }
438: float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
439: 	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
440: }
441: #if defined( USE_SHEEN )
442: float D_Charlie(float roughness, float NoH) {
443: 	float invAlpha  = 1.0 / roughness;
444: 	float cos2h = NoH * NoH;
445: 	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
446: }
447: float V_Neubelt(float NoV, float NoL) {
448: 	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
449: }
450: vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
451: 	vec3 N = geometry.normal;
452: 	vec3 V = geometry.viewDir;
453: 	vec3 H = normalize( V + L );
454: 	float dotNH = saturate( dot( N, H ) );
455: 	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
456: }
457: #endif
458: uniform bool receiveShadow;
459: uniform vec3 ambientLightColor;
460: uniform vec3 lightProbe[ 9 ];
461: vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
462: 	float x = normal.x, y = normal.y, z = normal.z;
463: 	vec3 result = shCoefficients[ 0 ] * 0.886227;
464: 	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
465: 	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
466: 	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
467: 	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
468: 	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
469: 	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
470: 	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
471: 	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
472: 	return result;
473: }
474: vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
475: 	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
476: 	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
477: 	return irradiance;
478: }
479: vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
480: 	vec3 irradiance = ambientLightColor;
481: 	#ifndef PHYSICALLY_CORRECT_LIGHTS
482: 		irradiance *= PI;
483: 	#endif
484: 	return irradiance;
485: }
486: #if 1 > 0
487: 	struct DirectionalLight {
488: 		vec3 direction;
489: 		vec3 color;
490: 		int shadow;
491: 		float shadowBias;
492: 		float shadowRadius;
493: 		vec2 shadowMapSize;
494: 	};
495: 	uniform DirectionalLight directionalLights[ 1 ];
496: 	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
497: 		directLight.color = directionalLight.color;
498: 		directLight.direction = directionalLight.direction;
499: 		directLight.visible = true;
500: 	}
501: #endif
502: #if 0 > 0
503: 	struct PointLight {
504: 		vec3 position;
505: 		vec3 color;
506: 		float distance;
507: 		float decay;
508: 		int shadow;
509: 		float shadowBias;
510: 		float shadowRadius;
511: 		vec2 shadowMapSize;
512: 		float shadowCameraNear;
513: 		float shadowCameraFar;
514: 	};
515: 	uniform PointLight pointLights[ 0 ];
516: 	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
517: 		vec3 lVector = pointLight.position - geometry.position;
518: 		directLight.direction = normalize( lVector );
519: 		float lightDistance = length( lVector );
520: 		directLight.color = pointLight.color;
521: 		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
522: 		directLight.visible = ( directLight.color != vec3( 0.0 ) );
523: 	}
524: #endif
525: #if 0 > 0
526: 	struct SpotLight {
527: 		vec3 position;
528: 		vec3 direction;
529: 		vec3 color;
530: 		float distance;
531: 		float decay;
532: 		float coneCos;
533: 		float penumbraCos;
534: 		int shadow;
535: 		float shadowBias;
536: 		float shadowRadius;
537: 		vec2 shadowMapSize;
538: 	};
539: 	uniform SpotLight spotLights[ 0 ];
540: 	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {
541: 		vec3 lVector = spotLight.position - geometry.position;
542: 		directLight.direction = normalize( lVector );
543: 		float lightDistance = length( lVector );
544: 		float angleCos = dot( directLight.direction, spotLight.direction );
545: 		if ( angleCos > spotLight.coneCos ) {
546: 			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
547: 			directLight.color = spotLight.color;
548: 			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
549: 			directLight.visible = true;
550: 		} else {
551: 			directLight.color = vec3( 0.0 );
552: 			directLight.visible = false;
553: 		}
554: 	}
555: #endif
556: #if 0 > 0
557: 	struct RectAreaLight {
558: 		vec3 color;
559: 		vec3 position;
560: 		vec3 halfWidth;
561: 		vec3 halfHeight;
562: 	};
563: 	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
564: 	uniform RectAreaLight rectAreaLights[ 0 ];
565: #endif
566: #if 0 > 0
567: 	struct HemisphereLight {
568: 		vec3 direction;
569: 		vec3 skyColor;
570: 		vec3 groundColor;
571: 	};
572: 	uniform HemisphereLight hemisphereLights[ 0 ];
573: 	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
574: 		float dotNL = dot( geometry.normal, hemiLight.direction );
575: 		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
576: 		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
577: 		#ifndef PHYSICALLY_CORRECT_LIGHTS
578: 			irradiance *= PI;
579: 		#endif
580: 		return irradiance;
581: 	}
582: #endif
583: #ifdef USE_FOG
584: 	uniform vec3 fogColor;
585: 	varying float fogDepth;
586: 	#ifdef FOG_EXP2
587: 		uniform float fogDensity;
588: 	#else
589: 		uniform float fogNear;
590: 		uniform float fogFar;
591: 	#endif
592: #endif
593: #ifdef USE_SHADOWMAP
594: 	#if 0 > 0
595: 		uniform sampler2D directionalShadowMap[ 0 ];
596: 		varying vec4 vDirectionalShadowCoord[ 0 ];
597: 	#endif
598: 	#if 0 > 0
599: 		uniform sampler2D spotShadowMap[ 0 ];
600: 		varying vec4 vSpotShadowCoord[ 0 ];
601: 	#endif
602: 	#if 0 > 0
603: 		uniform sampler2D pointShadowMap[ 0 ];
604: 		varying vec4 vPointShadowCoord[ 0 ];
605: 	#endif
606: 	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
607: 		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
608: 	}
609: 	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
610: 		return decodeHalfRGBA( texture2D( shadow, uv ) );
611: 	}
612: 	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
613: 		float occlusion = 1.0;
614: 		vec2 distribution = texture2DDistribution( shadow, uv );
615: 		float hard_shadow = step( compare , distribution.x );
616: 		if (hard_shadow != 1.0 ) {
617: 			float distance = compare - distribution.x ;
618: 			float variance = max( 0.00000, distribution.y * distribution.y );
619: 			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
620: 		}
621: 		return occlusion;
622: 	}
623: 	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {
624: 		const vec2 offset = vec2( 0.0, 1.0 );
625: 		vec2 texelSize = vec2( 1.0 ) / size;
626: 		vec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;
627: 		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
628: 		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
629: 		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
630: 		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );
631: 		vec2 f = fract( uv * size + 0.5 );
632: 		float a = mix( lb, lt, f.y );
633: 		float b = mix( rb, rt, f.y );
634: 		float c = mix( a, b, f.x );
635: 		return c;
636: 	}
637: 	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
638: 		float shadow = 1.0;
639: 		shadowCoord.xyz /= shadowCoord.w;
640: 		shadowCoord.z += shadowBias;
641: 		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
642: 		bool inFrustum = all( inFrustumVec );
643: 		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
644: 		bool frustumTest = all( frustumTestVec );
645: 		if ( frustumTest ) {
646: 		#if defined( SHADOWMAP_TYPE_PCF )
647: 			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
648: 			float dx0 = - texelSize.x * shadowRadius;
649: 			float dy0 = - texelSize.y * shadowRadius;
650: 			float dx1 = + texelSize.x * shadowRadius;
651: 			float dy1 = + texelSize.y * shadowRadius;
652: 			float dx2 = dx0 / 2.0;
653: 			float dy2 = dy0 / 2.0;
654: 			float dx3 = dx1 / 2.0;
655: 			float dy3 = dy1 / 2.0;
656: 			shadow = (
657: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
658: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
659: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
660: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
661: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
662: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
663: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
664: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
665: 				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
666: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
667: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
668: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
669: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
670: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
671: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
672: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
673: 				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
674: 			) * ( 1.0 / 17.0 );
675: 		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
676: 			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
677: 			float dx0 = - texelSize.x * shadowRadius;
678: 			float dy0 = - texelSize.y * shadowRadius;
679: 			float dx1 = + texelSize.x * shadowRadius;
680: 			float dy1 = + texelSize.y * shadowRadius;
681: 			shadow = (
682: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
683: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
684: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
685: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
686: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
687: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
688: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
689: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
690: 				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
691: 			) * ( 1.0 / 9.0 );
692: 		#elif defined( SHADOWMAP_TYPE_VSM )
693: 			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
694: 		#else
695: 			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
696: 		#endif
697: 		}
698: 		return shadow;
699: 	}
700: 	vec2 cubeToUV( vec3 v, float texelSizeY ) {
701: 		vec3 absV = abs( v );
702: 		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
703: 		absV *= scaleToCube;
704: 		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
705: 		vec2 planar = v.xy;
706: 		float almostATexel = 1.5 * texelSizeY;
707: 		float almostOne = 1.0 - almostATexel;
708: 		if ( absV.z >= almostOne ) {
709: 			if ( v.z > 0.0 )
710: 				planar.x = 4.0 - v.x;
711: 		} else if ( absV.x >= almostOne ) {
712: 			float signX = sign( v.x );
713: 			planar.x = v.z * signX + 2.0 * signX;
714: 		} else if ( absV.y >= almostOne ) {
715: 			float signY = sign( v.y );
716: 			planar.x = v.x + 2.0 * signY + 2.0;
717: 			planar.y = v.z * signY - 2.0;
718: 		}
719: 		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
720: 	}
721: 	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
722: 		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
723: 		vec3 lightToPosition = shadowCoord.xyz;
724: 		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
725: 		vec3 bd3D = normalize( lightToPosition );
726: 		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
727: 			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
728: 			return (
729: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
730: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
731: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
732: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
733: 				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
734: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
735: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
736: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
737: 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
738: 			) * ( 1.0 / 9.0 );
739: 		#else
740: 			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
741: 		#endif
742: 	}
743: #endif
744: float getShadowMask() {
745: 	float shadow = 1.0;
746: 	#ifdef USE_SHADOWMAP
747: 	#if 0 > 0
748: 	DirectionalLight directionalLight;
749: 	
750: 	#endif
751: 	#if 0 > 0
752: 	SpotLight spotLight;
753: 	
754: 	#endif
755: 	#if 0 > 0
756: 	PointLight pointLight;
757: 	
758: 	#endif
759: 	#endif
760: 	return shadow;
761: }
762: #ifdef USE_SPECULARMAP
763: 	uniform sampler2D specularMap;
764: #endif
765: #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
766: 	uniform float logDepthBufFC;
767: 	varying float vFragDepth;
768: 	varying float vIsPerspective;
769: #endif
770: #if 0 > 0
771: 	#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )
772: 		varying vec3 vViewPosition;
773: 	#endif
774: 	uniform vec4 clippingPlanes[ 0 ];
775: #endif
776: void main() {
777: #if 0 > 0
778: 	vec4 plane;
779: 	
780: 	#if 0 < 0
781: 		bool clipped = true;
782: 		
783: 		if ( clipped ) discard;
784: 	#endif
785: #endif
786: 	
787: 				vec4 diffuseColor = vInstanceColor;
788: 			
789: 	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
790: 	vec3 totalEmissiveRadiance = vInstanceEmissive;;
791: #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
792: 	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
793: #endif
794: #ifdef USE_MAP
795: 	vec4 texelColor = texture2D( map, vUv );
796: 	texelColor = mapTexelToLinear( texelColor );
797: 	diffuseColor *= texelColor;
798: #endif
799: #ifdef USE_COLOR
800: 	diffuseColor.rgb *= vColor;
801: #endif
802: #ifdef USE_ALPHAMAP
803: 	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
804: #endif
805: #ifdef ALPHATEST
806: 	if ( diffuseColor.a < ALPHATEST ) discard;
807: #endif
808: float specularStrength;
809: #ifdef USE_SPECULARMAP
810: 	vec4 texelSpecular = texture2D( specularMap, vUv );
811: 	specularStrength = texelSpecular.r;
812: #else
813: 	specularStrength = 1.0;
814: #endif
815: #ifdef USE_EMISSIVEMAP
816: 	vec4 emissiveColor = texture2D( emissiveMap, vUv );
817: 	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
818: 	totalEmissiveRadiance *= emissiveColor.rgb;
819: #endif
820: 	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
821: 	#ifdef DOUBLE_SIDED
822: 		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
823: 	#else
824: 		reflectedLight.indirectDiffuse += vIndirectFront;
825: 	#endif
826: #ifdef USE_LIGHTMAP
827: 	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
828: #endif
829: 	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
830: 	#ifdef DOUBLE_SIDED
831: 		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
832: 	#else
833: 		reflectedLight.directDiffuse = vLightFront;
834: 	#endif
835: 	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
836: #ifdef USE_AOMAP
837: 	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
838: 	reflectedLight.indirectDiffuse *= ambientOcclusion;
839: 	#if defined( USE_ENVMAP ) && defined( STANDARD )
840: 		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
841: 		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
842: 	#endif
843: #endif
844: 	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
845: #ifdef USE_ENVMAP
846: 	#ifdef ENV_WORLDPOS
847: 		vec3 cameraToFrag;
848: 		
849: 		if ( isOrthographic ) {
850: 			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
851: 		}  else {
852: 			cameraToFrag = normalize( vWorldPosition - cameraPosition );
853: 		}
854: 		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
855: 		#ifdef ENVMAP_MODE_REFLECTION
856: 			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
857: 		#else
858: 			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
859: 		#endif
860: 	#else
861: 		vec3 reflectVec = vReflect;
862: 	#endif
863: 	#ifdef ENVMAP_TYPE_CUBE
864: 		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
865: 	#elif defined( ENVMAP_TYPE_EQUIREC )
866: 		vec2 sampleUV;
867: 		reflectVec = normalize( reflectVec );
868: 		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
869: 		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
870: 		vec4 envColor = texture2D( envMap, sampleUV );
871: 	#elif defined( ENVMAP_TYPE_SPHERE )
872: 		reflectVec = normalize( reflectVec );
873: 		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );
874: 		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );
875: 	#else
876: 		vec4 envColor = vec4( 0.0 );
877: 	#endif
878: 	envColor = envMapTexelToLinear( envColor );
879: 	#ifdef ENVMAP_BLENDING_MULTIPLY
880: 		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
881: 	#elif defined( ENVMAP_BLENDING_MIX )
882: 		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
883: 	#elif defined( ENVMAP_BLENDING_ADD )
884: 		outgoingLight += envColor.xyz * specularStrength * reflectivity;
885: 	#endif
886: #endif
887: 	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
888: #if defined( TONE_MAPPING )
889: 	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
890: #endif
891: gl_FragColor = linearToOutputTexel( gl_FragColor );
892: #ifdef USE_FOG
893: 	#ifdef FOG_EXP2
894: 		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
895: 	#else
896: 		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
897: 	#endif
898: 	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
899: #endif
900: #ifdef PREMULTIPLIED_ALPHA
901: 	gl_FragColor.rgb *= gl_FragColor.a;
902: #endif
903: #ifdef DITHERING
904: 	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
905: #endif
906: }