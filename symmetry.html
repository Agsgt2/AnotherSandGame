<!DOCTYPE html>
<head>
	<title>Sandboy Symmetries</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0">

	<!-- My Stuff -->
	<script src="Libraries/Array.js"></script>
	<script src="Libraries/Async.js"></script>
	<script src="Libraries/Console.js"></script>
	<script src="Libraries/Bracketless.js"></script>
	<script src="Libraries/Document.js"></script>
	<script src="Libraries/Loop.js"></script>
	<script src="Libraries/Match.js"></script>
	<script src="Libraries/Report.js"></script>
	<script src="Libraries/Type.js"></script>
	<script src="Libraries/Event.js"></script>
	<script src="Libraries/Worker.js"></script>
	<script src="Libraries/Vector.js"></script>
	<script src="Libraries/PropertyEditor.js"></script>
	<script src="Libraries/Controls.js"></script>
	<script src="Libraries/Stage.js"></script>
	<script src="Libraries/Javascript.js"></script>
	<script src="Libraries/Math.js"></script>
	
	<!-- Someone Else's Stuff -->
	<script src="Libraries/three.min.js"></script>
	<script src="Libraries/BufferGeometryUtils.js"></script>
	<script src="Libraries/OrbitControls.js"></script>
	<script src="Libraries/WebVR.js"></script>
	<script src="Libraries/threex.dynamictexture.js"></script>
	<script src="Libraries/threex.dynamictext2dobject.js"></script>
	
	<style>
		
		@font-face {
			font-family: UbuntuMono;
			src: url("Fonts/UbuntuMono-R.ttf")
		}
		
		@font-face {
			font-family: Rosario;
			src: url("Fonts/Rosario-Regular.ttf")
		}
		
		#loading {
			font-family: Rosario;
			position: absolute;
			left: 50vw;
			transform: translateX(-50%);
			top: 25vh;
			text-align:center;
		}
		
		#loading img {
			width: 100px;
		}
		
		pre {
			tab-size: 4;
		}
		
		html {
		
		}
		
		p {}
		
		body {
			font-family: Rosario;
			margin: 20px;
			background-color: rgb(23, 29, 40);
			color: rgb(224, 224, 224);
		}
		
		pre {
			font-family: UbuntuMono;
		}
		
		article {
			font-size: 18px;
		}
		
		.demo {
			max-width: 200px;
			width: 35vw;
			max-height: 200px;
			height: 35vw;
			display: inline-block;
			position: relative;
			pointer-events: all;
		}
		
		#canvasContainer {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100vh;
			display: block;
			margin: 0;
			padding: 0;
			z-index: 1;
			pointer-events: none;
		}
		
		.group {
			background-color: rgb(45, 56, 77);
			position: relative;
			display: inline-block;
			border-radius: 15px;
			padding: 10px;
			margin-bottom: 4px;
		}
		
		.container {
			margin-top: 9px;
			margin-bottom: 9px;
			margin-right: 4.5px;
			pointer-events: none;
		}
	
	</style>
</head>

<body>

	<canvas id="canvasContainer"></canvas>
	<header>
		<h1>Sandboy Symmetries</h1>
	</header>
	<main>
	
		<article>

<h1>Intro</h1>
<p>In TodeSplat, you draw 2D diagrams to program elements.<br>
For example:</p>
<pre>
rule {
	@_ => _@
}
</pre>
<p>This makes an atom move to the right each tick.<br>
Let's represent the left-hand-side of our 2D diagram like this:</p>

<div class="container">
	<div id="rightGroup" class="group">
		<div class="demo" id="right"></div>
	</div>
</div>
<br>
<h1>Left and Right</h1>
<p>Now let's imagine you want this atom to randomly move left or right.<br>
You can write 'x', which flips the x-axis randomly:</p>
<pre>
rule x {
	@_ => _@
}
</pre>
<p>This means that one of two diagrams will be chosen:<br></p>

<div class="container">
<div id="rightLeft" class="group">
<div class="demo" id="rightLeft0"></div>
</div>
<div id="rightLeft" class="group">
<div class="demo" id="rightLeft1"></div>
</div></div>
<p>When you write the 'x' label, you are saying, "I don't care which way round the x-axis is."<br>
With this 'x' label, there are only two translations:</p>
<pre>
( x, y, 0 )
(-x, y, 0 )
</pre>
<br>
<h1>Sideways</h1>
You could also use the 'xz' label to make it go in any direction sideways:
<pre>
rule xz {
	@_ => _@
}
</pre>
<div class="container">
	<div id="side" class="group">
		<div class="demo" id="side0"></div>
	</div>
	<div id="side" class="group">
		<div class="demo" id="side1"></div>
	</div>
	<div id="side" class="group">
		<div class="demo" id="side2"></div>
	</div>
	<div id="side" class="group">
		<div class="demo" id="side3"></div>
	</div>
</div>
By writing 'xz', you are saying, "I don't care which way round the x-axis or z-axis are."
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
</pre>
<br>
<h1>Any Direction</h1>
You can use the 'xyz' label to make it go in ANY direction:
<pre>
rule xyz {
	@_ => _@
}
</pre>
<div class="container">
	<div id="any" class="group">
		<div class="demo" id="any0"></div>
	</div>
	<div id="any" class="group">
		<div class="demo" id="any1"></div>
	</div>
	<div id="any" class="group">
		<div class="demo" id="any2"></div>
	</div>
	<div id="any" class="group">
		<div class="demo" id="any3"></div>
	</div>
	<div id="any" class="group">
		<div class="demo" id="any4"></div>
	</div>
	<div id="any" class="group">
		<div class="demo" id="any5"></div>
	</div>
</div>
By writing 'xyz', you are saying, "I don't care which way round the x, y, or z-axes are."<br>
In this case, there are 6 relevant transformations:
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
( y, x, 0 )
( y,-x, 0 )
</pre>
<br>
<h1>Slide Right</h1>
Let's look at a slightly more complicated example now:
<pre>
rule {
	@  => _
	#_    #@
}
</pre>
This makes an atom slide down and to the right if there is an atom below it.<br>
<div class="container">
	<div id="slideRight" class="group">
		<div class="demo" id="slideRight0"></div>
	</div>
</div><br>
<h1>Slide Sideways</h1>
Again, we can use a symmetry label to make it randomly choose a certain direction sideways:
<pre>
rule xz {
	@  => _
	#_    #@
}
</pre>
<div class="container">
	<div id="slideSide" class="group">
		<div class="demo" id="slideSide0"></div>
	</div>
	<div id="slideSide" class="group">
		<div class="demo" id="slideSide1"></div>
	</div>
	<div id="slideSide" class="group">
		<div class="demo" id="slideSide2"></div>
	</div>
	<div id="slideSide" class="group">
		<div class="demo" id="slideSide3"></div>
	</div>
</div>
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
</pre><br>
<h1>Slide Anywhere</h1>
What about sliding in any direction?
<pre>
rule xyz {
	@  => _
	#_    #@
}
</pre>
I find it trickier to visualise all possibilities for this one.<br>
I think these are all the possible transformations:
<pre>
( x, y, 0 )    ( x, 0, y )
( x,-y, 0 )    ( x, 0,-y )
(-x, y, 0 )    (-x, 0, y )
(-x,-y, 0 )    (-x, 0,-y )

( 0, y, x )    ( y, x, 0 )
( 0,-y, x )    (-y, x, 0 )
( 0, y,-x )    ( y,-x, 0 )
( 0,-y,-x )    (-y,-x, 0 )

( 0, x, y )    ( y, 0, x )
( 0, x,-y )    (-y, 0, x )
( 0,-x, y )    ( y, 0,-x )
( 0,-x,-y )    (-y, 0,-x )

</pre>
And this is what they look like in 3D (not necessarily in order):
<div class="container">
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny0"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny1"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny2"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny3"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny4"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny5"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny6"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny7"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny8"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny9"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny10"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny11"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny12"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny13"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny14"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny15"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny16"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny17"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny18"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny19"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny20"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny21"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny22"></div>
	</div>
	<div id="slideAny" class="group">
		<div class="demo" id="slideAny23"></div>
	</div>
</div>
<br>
<h1>Follow Through</h1>
During an event, only one symmetry is selected, even for multiple rules.<br>
In the following code, the second rule will NEVER be reached:
<pre>
element Foo {
	
	rule x {
		@_ => _@
	}
	
	rule x {
		@_ => _@
		#     #
	}
}
</pre>
For all rules, the x-axis is either (1) flipped, or (2) not flipped.<br>
It is not flipped on a per-rule basis.<br>
So the potential sequences of diagrams are either these:<br>
<div class="container">
	<div id="follow" class="group">
		<div class="demo" id="follow0"></div>
		<div class="demo" id="follow1"></div>
	</div><br>
	<br>Or these:<br><br>
	<div id="followOther" class="group">
		<div class="demo" id="follow2"></div>
		<div class="demo" id="follow3"></div>
	</div>
</div>
Please note that I have grouped together the linked diagrams in the same box to demonstrate that they are in a sequence together.<br>
<br>
<h1 id="diffo">Follow Through - Different Symmetries</h1>
The chosen symmetry follows through even when rules have different symmetry labels.<br>
ie: Where applicable, a chosen symmetry will stay consistent from one rule to the next.<br>
Look at this:
<pre>
element Foo {
	
	rule xz {
		@_ => _@
	}
	
	rule x {
		@_ => _@
		#     #
	}
}
</pre>
When the first rule points to the right, the second rule points right too:
<div class="container">
<div id="diffoRight" class="group">
	<div class="demo" id="diffoRight0"></div>
	<div class="demo" id="diffoRight1"></div>
</div>
</div>
When the first rule points to the left, the second rule points left too:
<div class="container">
<div id="diffoLeft" class="group">
	<div class="demo" id="diffoLeft0"></div>
	<div class="demo" id="diffoLeft1"></div>
</div>
</div>
But sometimes the first rule points along the z-axis.<br>
In these cases, it wouldn't make much sense to try to match this to the second rule.<br>
When this happens, the second rule randomly picks one of its translations.<br>
For example, you could have this combination:
<div class="container">
<div id="diffoZ" class="group">
	<div class="demo" id="diffoZ0"></div>
	<div class="demo" id="diffoZ1"></div>
</div>
</div>
For completeness, let's now list all possible combinations of these rules:<br>
Note: Some rules have more chance of happening than others.
<div class="container">
	<div id="diffoAll" class="group">
		<div class="demo" id="diffoAll0"></div>
		<div class="demo" id="diffoAll1"></div>
	</div>
	<div id="diffoAll" class="group">
		<div class="demo" id="diffoAll2"></div>
		<div class="demo" id="diffoAll3"></div>
	</div>
	<div id="diffoAll" class="group">
		<div class="demo" id="diffoAll4"></div>
		<div class="demo" id="diffoAll5"></div>
	</div>
	<div id="diffoAll" class="group">
		<div class="demo" id="diffoAll6"></div>
		<div class="demo" id="diffoAll7"></div>
	</div>
	<div id="diffoAll" class="group">
		<div class="demo" id="diffoAll8"></div>
		<div class="demo" id="diffoAll9"></div>
	</div>
	<div id="diffoAll" class="group">
		<div class="demo" id="diffoAll10"></div>
		<div class="demo" id="diffoAll11"></div>
	</div>
</div>

<br>
<h1 id="looping">Looping</h1>
In all these examples so far, one random translation is chosen per event.<br>
However, in some programs, you might want to loop through all translations instead of only picking one.<br>
In the next version of TodeSplat, you will be able to use the "for" keyword to do this.<br>
For example:
<pre>
for(x) rule {
	@  => _
	#_    #@
}
</pre>
This example loops through each possible x-axis translation.<br>
To recap, there are two possible translations here:<br>
<div class="container">
	<div id="recap" class="group">
		<div class="demo" id="recap0"></div>
	</div>
	<div id="recap" class="group">
		<div class="demo" id="recap1"></div>
	</div>
</div>
This means that this rule chooses between 2 possible sequences of translations (2 factorial):
<div class="container">
	<div id="loopx" class="group">
		<div class="demo" id="loopx0"></div>
		<div class="demo" id="loopx1"></div>
	</div>
	<div id="recap" class="group">
		<div class="demo" id="loopx2"></div>
		<div class="demo" id="loopx3"></div>
	</div>
</div>

<br>
<h1 id="longlooping">Long Looping</h1>
But what if there are more possible translations?
Let's look at this example:
<pre>
for(xz) rule {
	@  => _
	#_    #@
}
</pre>
It loops through each possible x-axis and z-axis translation (and combinations of the two).<br>
In other words, any direction sideways.<br>
To recap, these are the 4 possible translations:<br>
<div class="container">
	<div id="recapxz" class="group">
		<div class="demo" id="recapxz0"></div>
	</div>
	<div id="recapxz" class="group">
		<div class="demo" id="recapxz1"></div>
	</div>
	<div id="recapxz" class="group">
		<div class="demo" id="recapxz2"></div>
	</div>
	<div id="recapxz" class="group">
		<div class="demo" id="recapxz3"></div>
	</div>
</div>

This means that there are 24 different potential sequences (4 factorial):<br>
<!-- generated html -->
<div class="container">
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz0"></div>
		<div class="demo" id="loopxz1"></div>
		<div class="demo" id="loopxz2"></div>
		<div class="demo" id="loopxz3"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz4"></div>
		<div class="demo" id="loopxz5"></div>
		<div class="demo" id="loopxz6"></div>
		<div class="demo" id="loopxz7"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz8"></div>
		<div class="demo" id="loopxz9"></div>
		<div class="demo" id="loopxz10"></div>
		<div class="demo" id="loopxz11"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz12"></div>
		<div class="demo" id="loopxz13"></div>
		<div class="demo" id="loopxz14"></div>
		<div class="demo" id="loopxz15"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz16"></div>
		<div class="demo" id="loopxz17"></div>
		<div class="demo" id="loopxz18"></div>
		<div class="demo" id="loopxz19"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz20"></div>
		<div class="demo" id="loopxz21"></div>
		<div class="demo" id="loopxz22"></div>
		<div class="demo" id="loopxz23"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz24"></div>
		<div class="demo" id="loopxz25"></div>
		<div class="demo" id="loopxz26"></div>
		<div class="demo" id="loopxz27"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz28"></div>
		<div class="demo" id="loopxz29"></div>
		<div class="demo" id="loopxz30"></div>
		<div class="demo" id="loopxz31"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz32"></div>
		<div class="demo" id="loopxz33"></div>
		<div class="demo" id="loopxz34"></div>
		<div class="demo" id="loopxz35"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz36"></div>
		<div class="demo" id="loopxz37"></div>
		<div class="demo" id="loopxz38"></div>
		<div class="demo" id="loopxz39"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz40"></div>
		<div class="demo" id="loopxz41"></div>
		<div class="demo" id="loopxz42"></div>
		<div class="demo" id="loopxz43"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz44"></div>
		<div class="demo" id="loopxz45"></div>
		<div class="demo" id="loopxz46"></div>
		<div class="demo" id="loopxz47"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz48"></div>
		<div class="demo" id="loopxz49"></div>
		<div class="demo" id="loopxz50"></div>
		<div class="demo" id="loopxz51"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz52"></div>
		<div class="demo" id="loopxz53"></div>
		<div class="demo" id="loopxz54"></div>
		<div class="demo" id="loopxz55"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz56"></div>
		<div class="demo" id="loopxz57"></div>
		<div class="demo" id="loopxz58"></div>
		<div class="demo" id="loopxz59"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz60"></div>
		<div class="demo" id="loopxz61"></div>
		<div class="demo" id="loopxz62"></div>
		<div class="demo" id="loopxz63"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz64"></div>
		<div class="demo" id="loopxz65"></div>
		<div class="demo" id="loopxz66"></div>
		<div class="demo" id="loopxz67"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz68"></div>
		<div class="demo" id="loopxz69"></div>
		<div class="demo" id="loopxz70"></div>
		<div class="demo" id="loopxz71"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz72"></div>
		<div class="demo" id="loopxz73"></div>
		<div class="demo" id="loopxz74"></div>
		<div class="demo" id="loopxz75"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz76"></div>
		<div class="demo" id="loopxz77"></div>
		<div class="demo" id="loopxz78"></div>
		<div class="demo" id="loopxz79"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz80"></div>
		<div class="demo" id="loopxz81"></div>
		<div class="demo" id="loopxz82"></div>
		<div class="demo" id="loopxz83"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz84"></div>
		<div class="demo" id="loopxz85"></div>
		<div class="demo" id="loopxz86"></div>
		<div class="demo" id="loopxz87"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz88"></div>
		<div class="demo" id="loopxz89"></div>
		<div class="demo" id="loopxz90"></div>
		<div class="demo" id="loopxz91"></div>
	</div>
	<div id="loopxz" class="group">
		<div class="demo" id="loopxz92"></div>
		<div class="demo" id="loopxz93"></div>
		<div class="demo" id="loopxz94"></div>
		<div class="demo" id="loopxz95"></div>
	</div>
</div>

These sequences are calculated and processed when the page loads.<br>
This means that TodeSplat generates Javascript that runs faster.<br>
Faster Javascript means more sand to test out.<br>
Is this a good idea? Probably not, but I want to experiment with it and learn.<br>
<br>
<h1 id="xlonglooping">Extremely Long Looping</h1>
But what if we wanted to loop through even more translations?<br>
Let's look at this example:<br>
<pre>
for(xyz) rule {
	@  => _
	#_    #@
}
</pre>
It loops through each possible x-axis and z-axis and y-axis translation (and combinations of the three).<br>
To recap, these are the 24 possible translations:<br>
<div class="container">
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop0"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop1"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop2"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop3"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop4"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop5"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop6"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop7"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop8"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop9"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop10"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop11"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop12"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop13"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop14"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop15"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop16"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop17"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop18"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop19"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop20"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop21"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop22"></div>
	</div>
	<div id="slideAnyLoop" class="group">
		<div class="demo" id="slideAnyLoop23"></div>
	</div>
</div>
<br>
This means that there would be 620448401733239439360000 possible sequences of translations.<br>
Clearly, this is too many to pre-process.<br>
<br>
On one hand, I could give up on trying to pre-process sequences of translations.<br>
This would be much easier but would cause a huge performance hit for the next batch of elements I want to make.<br>
<br>
However, I won't give up yet because I have a theory about how to get around this issue.<br>
Instead of pre-processing all (24 factorial) potential sequences, perhaps I could just pre-process a smaller subset of them.<br>
Sort of like... a pseudo-random list of possible sequences.<br>
Because... when I'm coding with TodeSplat I don't really care about 'completeness' of these symmetries.<br>
I care more about just making my elements work (without any biases in any direction).<br>
To help understand this better, I'm going to make a new demo to test out some ideas.<br>
I'll link it here when I've started work on it.<br>
<br>
Update: I've now made the <a style="color: #FC0" href="./demo2d.html">next demo</a>.
<br>

		</article>
	
	</main>

	<!-- Structure -->
	<!--<script src="Source/Universe.js"></script>-->
	<script src="Source/World.js"></script>
	<script src="Source/Space.js"></script>
	<script src="Source/Site.js"></script>
	<script src="Source/Atom.js"></script>
	<script src="Source/Element.js"></script>
	<script src="Source/Rule.js"></script>
	<script src="Source/Event.js"></script>
	<script src="Source/Character.js"></script>
	
	<!-- Helpers -->
	<script src="Source/Symmetry.js"></script>
	<script src="Source/EventWindow.js"></script>
	<script src="Source/Behave.js"></script>
	<script src="Source/Random.js"></script>
	<script src="Source/TodeSplat.js"></script>
	
	<!-- Entities -->
	<!--<script src="Source/Dropper.js"></script>-->
	<script src="Source/Floor.js"></script>
	<script src="Source/Lighting.js"></script>
	
	<!-- Elements -->
	<script src="Elements/Globals.js"></script>
	<script src="Elements/Simple.js"></script>
	<!--<script src="Elements/Presets.js"></script>
	<script src="Elements/Sandbox.js"></script>
	<script src="Elements/Weather.js"></script>
	<script src="Elements/Explosive.js"></script>
	<script src="Elements/Life.js"></script>
	<script src="Elements/T2Tile.js"></script>-->
	<!--<script src="Elements/Tutorial.js"></script>-->
	
	<!-- Main -->
	<script>
		
		const urlParams = new URLSearchParams(window.location.search)
		const isStatic = urlParams.has("static")
		const isCache = urlParams.has("cache")
		
		document.fonts.ready.then(() => {
		
			if (!isStatic) {
				boxGeometry = new THREE.BoxGeometry(1, 1, 1)
				boxLabelGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01)
			}
		
			const makeBox = (character, colour, emissive = colour) => {
			
				const size = 32
			
				const dynamicTexture = new THREEx.DynamicTexture(size, size)
				dynamicTexture.context.font	= `${size * 3/4}px UbuntuMono`;
				dynamicTexture.clear(emissive)
				dynamicTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
				dynamicTexture.drawText(character, (size * 1/4)+(size*1/8)/2, (size*3/4)-(size*1/8)/2, "rgb(23, 29, 40)")
				
				const alphaTexture = new THREEx.DynamicTexture(size, size)
				alphaTexture.context.font	= `${size * 3/4}px UbuntuMono`;
				alphaTexture.clear("black")
				alphaTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
				alphaTexture.drawText(character, (size * 1/4)+(size*1/8)/2, (size*3/4)-(size*1/8)/2, "white")
				
				const dynamicMaterial = new THREE.MeshBasicMaterial({
					map: dynamicTexture.texture,
					alphaMap: alphaTexture.texture,
					alphaTest: 0.5,
				})
				
				const boxLabel = new THREE.Mesh(boxLabelGeometry, dynamicMaterial)
				/*const boxLabel = new THREEx.DynamicText2DObject(character)
				boxLabel.dynamicTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
				*/
			
				const boxMaterial = new THREE.MeshStandardMaterial({color: colour, emissive})
				const box = new THREE.Mesh(boxGeometry, boxMaterial)
				return {box, boxLabel}
			}
			
			const getColours = (character) => {
				if (character == "@") return ["#ffcc00", "#ffa34d"]
				if (character == "#") return ["#4b5971"]
				if (character == "_") return ["grey"]
				return ["grey"]
			}
			
			let dummyCamera = undefined
			
			const canvas = $("#canvasContainer")
			if (!isStatic) renderer = new THREE.WebGLRenderer({canvas, alpha: true, antialias: true})
			
			const sceneElements = []
			const addScene = (elem, fn) => {
				sceneElements.push({elem, fn})
			}
			
			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}
			
			const clearColor = new THREE.Color('#000')
			
			const render = (time) => {
				time *= 0.001
				resizeRendererToDisplaySize(renderer)
				renderer.setScissorTest(false)
				renderer.setClearColor(clearColor, 0)
				renderer.clear(true, true)
				renderer.setScissorTest(true)
				
				const transform = `translateY(${window.scrollY}px)`
				renderer.domElement.style.transform = transform
				
				for (const {elem, fn} of sceneElements) {
					const rect = elem.getBoundingClientRect()
					const {left, right, top, bottom, width, height} = rect
					
					const isOffscreen = 
						bottom < 0 ||
						top > renderer.domElement.clientHeight ||
						right < 0 ||
						left > renderer.domElement.clientWidth
					
					if (!isOffscreen) {
						const positiveYUpBottom = renderer.domElement.clientHeight - bottom
						renderer.setScissor(left, positiveYUpBottom, width, height)
						renderer.setViewport(left, positiveYUpBottom, width, height)
						
						fn(time, rect)
					}
					
				}
				
				requestAnimationFrame(render)
			}
			
			let cacheRenderer = undefined
			let cacheCanvas = undefined
			if (isCache) {
				cacheCanvas = HTML `<canvas style="width: 200px; height: 200px;"></canvas>` //<script> (for broken formatting in my text editor)
				document.body.prepend(cacheCanvas)
				cacheRenderer = new THREE.WebGLRenderer({canvas: cacheCanvas, alpha: true, antialias: true, preserveDrawingBuffer: true})
				cacheRenderer.setSize(200, 200, false)
			}
			
			urls = []
			const cacheScene = (name, scene, camera) => {
				if (!isCache) throw new Error("You shouldn't be caching a scene when not in cache mode.")
				cacheRenderer.render(scene, camera)
				const url = cacheCanvas.toDataURL()
				//const downloader = HTML `<a href="${url}" download="${name}.png">${name}</a>` //<script> (for broken formatting in my text editor)
				//document.body.prepend(downloader)
				urls.push({download: url, filename: name})
				
			}
			
			downloadCache = () => {
				const files = urls
				function download_next(i) {
					if (i >= files.length) {
						return;
					}
					var a = document.createElement('a');
					a.href = files[i].download;
					a.target = '_parent';
					// Use a.download if available, it prevents plugins from opening.
					if ('download' in a) {
						a.download = files[i].filename;
					}
					// Add a to the doc for click to work.
					(document.body || document.documentElement).appendChild(a);
					if (a.click) {
						a.click(); // The click method is supported by most browsers.
					} else {
						$(a).click(); // Backup using jquery
					}
					// Delete the temporary link.
					a.parentNode.removeChild(a);
					// Download the next file with a small timeout. The timeout is necessary
					// for IE, which will otherwise only download the first file.
					setTimeout(function() {
						download_next(i + 1);
					}, 500);
				}
				// Initiate the first download.
				download_next(0);
			}
			
			const makeDemo = (name, group, rule) => {
				
				if (isStatic) return
				
				const scene = new THREE.Scene()
				
				//const fov = 30
				const fov = 15
				const camera = new THREE.OrthographicCamera(-2.5, 2.5, 2.5, -2.5)
				//const camera = new THREE.PerspectiveCamera(fov)
				camera.position.set(-1, 2, 10)
				//camera.position.set(0, 3, 15)
				camera.lookAt(0, 0, 0)
				
				/*{
					const color = 0xFFFFFF;
					const intensity = 1;
					const light = new THREE.DirectionalLight(color, intensity);
					light.position.set(-1, 2, 4);
					scene.add(light);
				}*/
				
				const sun = makeSun()
				//sun.position.set(200, 400, 400)
				scene.add(sun)
				
				const elem = $(`#${name}`)
				
				if (elem == null) return
				if (rule == undefined) return
				
				for (const event of rule) {
					const colours = getColours(event.input.name)
					const {box, boxLabel} = makeBox(event.input.name, ...colours)
					const position = SITE_POSITIONS[event.siteNumber]
					box.position.set(...position)
					boxLabel.position.set(...position)
					//boxLabel.position.set(position[0], position[1], position[2] + 0.51)
					scene.add(box)
					scene.add(boxLabel)				
				}
				
				let orbit = undefined
				if (true || !dummyCamera) {
					const container = $(`#${group}`).parentElement
					if (container.classList.contains("container")) {
						orbit = new THREE.OrbitControls(camera, container)
						orbit.mouseButtons.RIGHT = THREE.MOUSE.ROTATE
						orbit.mouseButtons.MIDDLE = undefined
						orbit.enableKeys = false
						orbit.enableDamping = true
						orbit.enableZoom = false
						orbit.touches = {
							ONE: THREE.TOUCH.ROTATE,
						}
						//stage.on.process(orbit.o.update)
						dummyCamera = camera
					}
				}
				else {
					/*stage.on.process(() => {
						stage.camera.position.set(...dummyCamera.position)
						stage.camera.lookAt(0, 0, 0)
					})*/
				}
				
				addScene(elem, (time, rect) => {
					camera.aspect = rect.width / rect.height
					camera.updateProjectionMatrix()
					if (orbit) orbit.update()
					renderer.render(scene, camera)
				})
				
				if (!isCache) return
				cacheScene(name, scene, camera)
				
			}
			
			TodeSplat `
				element Dummy {
					rule {
						@_ => _@
					}
					
					rule {
						_@ => @_
					}
					
					rule side {
						_@ => @_
					}
					
					rule side {
						@_ => _@
					}
					
					rule {
						_ => @
						@    _
					}
					
					rule {
						@ => _
						_    @
					}
					
					// 6
					rule {
						@  => _
						#_    #@
					}
					
					rule {
						 @ =>  _
						_#    @#
					}
					
					rule side {
						 @ =>  _
						_#    @#
					}
					
					rule side {
						@  => _
						#_    #@
					}
					
					//10
					rule {
						#_    #@
						@  => _
					}
					
					rule top {
						#_    #@
						@  => _
					}
					
					rule top {
						@  => _
						#_    #@
					}
					
					//??
					rule {
						_#    @#
						 @ =>  _
					}
					
					rule {
						#@ => ..
						_     .
					}
					
					rule {
						 _     .
						@# => ..
					}
					
					//Reflected
					rule {
						_     @
						#@ => #_
					}
				}
			`
			
			const getBaseRule = (ruleNumber, element = Dummy) => element.rules[ruleNumber] && element.rules[ruleNumber].reflections[0][0]
			
			makeDemo("right", "rightGroup", getBaseRule(0))
			makeDemo("rightLeft0", "rightLeft", getBaseRule(0))
			makeDemo("rightLeft1", "rightLeft", getBaseRule(1))
			makeDemo("side0", "side", getBaseRule(0))
			makeDemo("side1", "side", getBaseRule(1))
			makeDemo("side2", "side", getBaseRule(2))
			makeDemo("side3", "side", getBaseRule(3))
			makeDemo("any0", "any", getBaseRule(0))
			makeDemo("any1", "any", getBaseRule(1))
			makeDemo("any2", "any", getBaseRule(2))
			makeDemo("any3", "any", getBaseRule(3))
			makeDemo("any4", "any", getBaseRule(4))
			makeDemo("any5", "any", getBaseRule(5))
			makeDemo("slideRight0", "slideRight", getBaseRule(6))
			makeDemo("slideSide0", "slideSide", getBaseRule(6))
			makeDemo("slideSide1", "slideSide", getBaseRule(7))
			makeDemo("slideSide2", "slideSide", getBaseRule(8))
			makeDemo("slideSide3", "slideSide", getBaseRule(9))
			
			TodeSplat `
				element SlideAny {
					
					// x y 0
					rule {
						@  => _
						#_    #@
					}
					
					rule {
						 @ =>  _
						_#    @#
					}
					
					rule {
						#_    #@
						@  => _
					}
					
					rule {
						_#    @#
						 @ =>  _
					}
					
					// x 0 y
					rule top {
						#_    #@
						@  => _
					}
					
					rule top {
						_#    @#
						 @ =>  _
					}
					
					rule top {
						@  => _
						#_    #@
					}
					
					rule top {
						 @ =>  _
						_#    @#
					}
					
					// 0 y x
					rule side {
						#_    #@
						@  => _
					}
					
					rule side {
						_#    @#
						 @ =>  _
					}
					
					rule side {
						@  => _
						#_    #@
					}
					
					rule side {
						 @ =>  _
						_#    @#
					}
					
					// y x 0
					rule {
						_  => .
						#@    ..
					}
					
					rule {
						 _ =>  _
						@#    @#
					}
					
					rule {
						#@    #@
						_  => _
					}
					
					rule {
						@#    @#
						 _ =>  _
					}
					
					// 0 x y
					rule side {
						 _ =>  .
						@#    ..
					}
					
					rule side {
						_  => .
						#@    ..
					}
					
					rule side {
						@#    ..
						 _ =>  .
					}
					
					rule side {
						#@    ..
						_  => .
					}
					
					// y 0 x
					rule top {
						#@ => ..
						_     .
					}
					
					rule top {
						@# => ..
						 _     .
					}
					
					rule top {
						_     .
						#@ => ..
					}
					
					rule top {
						 _     .
						@# => ..
					}
					
				}
			`
			
			makeDemo("slideAny0", "slideAny", getBaseRule(0, SlideAny))
			makeDemo("slideAny1", "slideAny", getBaseRule(1, SlideAny))
			makeDemo("slideAny2", "slideAny", getBaseRule(2, SlideAny))
			makeDemo("slideAny3", "slideAny", getBaseRule(3, SlideAny))
			makeDemo("slideAny4", "slideAny", getBaseRule(4, SlideAny))
			makeDemo("slideAny5", "slideAny", getBaseRule(5, SlideAny))
			makeDemo("slideAny6", "slideAny", getBaseRule(6, SlideAny))
			makeDemo("slideAny7", "slideAny", getBaseRule(7, SlideAny))
			makeDemo("slideAny8", "slideAny", getBaseRule(8, SlideAny))
			makeDemo("slideAny9", "slideAny", getBaseRule(9, SlideAny))
			makeDemo("slideAny10", "slideAny", getBaseRule(10, SlideAny))
			makeDemo("slideAny11", "slideAny", getBaseRule(11, SlideAny))
			makeDemo("slideAny12", "slideAny", getBaseRule(12, SlideAny))
			makeDemo("slideAny13", "slideAny", getBaseRule(13, SlideAny))
			makeDemo("slideAny14", "slideAny", getBaseRule(14, SlideAny))
			makeDemo("slideAny15", "slideAny", getBaseRule(15, SlideAny))
			makeDemo("slideAny16", "slideAny", getBaseRule(16, SlideAny))
			makeDemo("slideAny17", "slideAny", getBaseRule(17, SlideAny))
			makeDemo("slideAny18", "slideAny", getBaseRule(18, SlideAny))
			makeDemo("slideAny19", "slideAny", getBaseRule(19, SlideAny))
			makeDemo("slideAny20", "slideAny", getBaseRule(20, SlideAny))
			makeDemo("slideAny21", "slideAny", getBaseRule(21, SlideAny))
			makeDemo("slideAny22", "slideAny", getBaseRule(22, SlideAny))
			makeDemo("slideAny23", "slideAny", getBaseRule(23, SlideAny))
			
			TodeSplat `
				element FollowDummy {
					
					rule {
						@_ => _@
					}
					
					rule {
						_@ => @_
					}
					
					rule {
						@_ => _@
						#     #
					}
					
					rule {
						_@ => @_
						 #     #
					}
					
					rule side {
						_@ => @_
					}
					
					rule side {
						@_ => _@
					}
				}
			`
			
			makeDemo("follow0", "follow", getBaseRule(0, FollowDummy))
			makeDemo("follow1", "follow", getBaseRule(2, FollowDummy))
			
			makeDemo("follow2", "followOther", getBaseRule(1, FollowDummy))
			makeDemo("follow3", "followOther", getBaseRule(3, FollowDummy))
			
			makeDemo("diffoRight0", "diffoRight", getBaseRule(0, FollowDummy), "group")
			makeDemo("diffoRight1", "diffoRight", getBaseRule(2, FollowDummy), "group")
			
			makeDemo("diffoLeft0", "diffoLeft", getBaseRule(1, FollowDummy))
			makeDemo("diffoLeft1", "diffoLeft", getBaseRule(3, FollowDummy))
			
			makeDemo("diffoZ0", "diffoZ", getBaseRule(4, FollowDummy))
			makeDemo("diffoZ1", "diffoZ", getBaseRule(2, FollowDummy))
			
			makeDemo("diffoAll0", "diffoAll", getBaseRule(0, FollowDummy))
			makeDemo("diffoAll1", "diffoAll", getBaseRule(2, FollowDummy))
			makeDemo("diffoAll2", "diffoAll", getBaseRule(1, FollowDummy))
			makeDemo("diffoAll3", "diffoAll", getBaseRule(3, FollowDummy))
			makeDemo("diffoAll4", "diffoAll", getBaseRule(4, FollowDummy))
			makeDemo("diffoAll5", "diffoAll", getBaseRule(2, FollowDummy))
			makeDemo("diffoAll6", "diffoAll", getBaseRule(4, FollowDummy))
			makeDemo("diffoAll7", "diffoAll", getBaseRule(3, FollowDummy))
			
			makeDemo("diffoAll8", "diffoAll", getBaseRule(5, FollowDummy))
			makeDemo("diffoAll9", "diffoAll", getBaseRule(2, FollowDummy))
			makeDemo("diffoAll10", "diffoAll", getBaseRule(5, FollowDummy))
			makeDemo("diffoAll11", "diffoAll", getBaseRule(3, FollowDummy))
			
			TodeSplat `
				element EventWindowDummy {
					rule XYZ {
						  .      .
						 ..     ..
						@.. => ...
					}
				}
			`	
			
			//makeDemo("eventWindow0", "diffoAll", getBaseRule(0, EventWindowDummy))		
			
			TodeSplat `
				element Recap {
					rule { 
						@  => .
						#_    ..
					}
					
					rule { 
						 @ =>  .
						_#    ..
					}
					
					rule side { 
						 @ =>  .
						_#    ..
					}
					
					rule side { 
						@  => .
						#_    ..
					}
				}
			`
			
			makeDemo("recap0", "recap", getBaseRule(0, Recap))
			makeDemo("recap1", "recap", getBaseRule(1, Recap))
			
			makeDemo("loopx0", "loopx", getBaseRule(0, Recap))
			makeDemo("loopx1", "loopx", getBaseRule(1, Recap))
			makeDemo("loopx2", "loopx", getBaseRule(1, Recap))
			makeDemo("loopx3", "loopx", getBaseRule(0, Recap))
			
			makeDemo("recapxz0", "recapxz", getBaseRule(0, Recap))
			makeDemo("recapxz1", "recapxz", getBaseRule(1, Recap))
			makeDemo("recapxz2", "recapxz", getBaseRule(2, Recap))
			makeDemo("recapxz3", "recapxz", getBaseRule(3, Recap))
			
			
			// Thanks stackoverflow
			perm = (xs) => {
			  let ret = [];

			  for (let i = 0; i < xs.length; i = i + 1) {
				let rest = perm(xs.slice(0, i).concat(xs.slice(i + 1)));

				if(!rest.length) {
				  ret.push([xs[i]])
				} else {
				  for(let j = 0; j < rest.length; j = j + 1) {
					ret.push([xs[i]].concat(rest[j]))
				  }
				}
			  }
			  return ret;
			}
			
			const xzperms = perm([0, 1, 2, 3])
			
			let xzid = 0
			
			for (const xzperm of xzperms) {
				makeDemo(`loopxz${xzid++}`, "loopxz", getBaseRule(xzperm[0], Recap))
				makeDemo(`loopxz${xzid++}`, "loopxz", getBaseRule(xzperm[1], Recap))
				makeDemo(`loopxz${xzid++}`, "loopxz", getBaseRule(xzperm[2], Recap))
				makeDemo(`loopxz${xzid++}`, "loopxz", getBaseRule(xzperm[3], Recap))
			}
			
			
			
			makeDemo("slideAnyLoop0", "slideAnyLoop", getBaseRule(0, SlideAny))
			makeDemo("slideAnyLoop1", "slideAnyLoop", getBaseRule(1, SlideAny))
			makeDemo("slideAnyLoop2", "slideAnyLoop", getBaseRule(2, SlideAny))
			makeDemo("slideAnyLoop3", "slideAnyLoop", getBaseRule(3, SlideAny))
			makeDemo("slideAnyLoop4", "slideAnyLoop", getBaseRule(4, SlideAny))
			makeDemo("slideAnyLoop5", "slideAnyLoop", getBaseRule(5, SlideAny))
			makeDemo("slideAnyLoop6", "slideAnyLoop", getBaseRule(6, SlideAny))
			makeDemo("slideAnyLoop7", "slideAnyLoop", getBaseRule(7, SlideAny))
			makeDemo("slideAnyLoop8", "slideAnyLoop", getBaseRule(8, SlideAny))
			makeDemo("slideAnyLoop9", "slideAnyLoop", getBaseRule(9, SlideAny))
			makeDemo("slideAnyLoop10", "slideAnyLoop", getBaseRule(10, SlideAny))
			makeDemo("slideAnyLoop11", "slideAnyLoop", getBaseRule(11, SlideAny))
			makeDemo("slideAnyLoop12", "slideAnyLoop", getBaseRule(12, SlideAny))
			makeDemo("slideAnyLoop13", "slideAnyLoop", getBaseRule(13, SlideAny))
			makeDemo("slideAnyLoop14", "slideAnyLoop", getBaseRule(14, SlideAny))
			makeDemo("slideAnyLoop15", "slideAnyLoop", getBaseRule(15, SlideAny))
			makeDemo("slideAnyLoop16", "slideAnyLoop", getBaseRule(16, SlideAny))
			makeDemo("slideAnyLoop17", "slideAnyLoop", getBaseRule(17, SlideAny))
			makeDemo("slideAnyLoop18", "slideAnyLoop", getBaseRule(18, SlideAny))
			makeDemo("slideAnyLoop19", "slideAnyLoop", getBaseRule(19, SlideAny))
			makeDemo("slideAnyLoop20", "slideAnyLoop", getBaseRule(20, SlideAny))
			makeDemo("slideAnyLoop21", "slideAnyLoop", getBaseRule(21, SlideAny))
			makeDemo("slideAnyLoop22", "slideAnyLoop", getBaseRule(22, SlideAny))
			makeDemo("slideAnyLoop23", "slideAnyLoop", getBaseRule(23, SlideAny))
			
			
			
			
			if (!isStatic) return requestAnimationFrame(render)
			
			$$(".demo").forEach(e => {
				const img = new Image()
				img.style = "width: 100%;"
				img.src = `SymmetryCache/${e.id}.png`
				e.append(img)
			})
		})
		
	</script>
	
</body>
