<!DOCTYPE html>
<head>
	<title>Sandboy Symmetries</title>
	<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0">
	<meta charset="utf-8"/>

	<!-- My Stuff -->
	<script src="Libraries/Array.js"></script>
	<script src="Libraries/Async.js"></script>
	<script src="Libraries/Console.js"></script>
	<script src="Libraries/Bracketless.js"></script>
	<script src="Libraries/Document.js"></script>
	<script src="Libraries/Loop.js"></script>
	<script src="Libraries/Match.js"></script>
	<script src="Libraries/Report.js"></script>
	<script src="Libraries/Type.js"></script>
	<script src="Libraries/Event.js"></script>
	<script src="Libraries/Worker.js"></script>
	<script src="Libraries/Vector.js"></script>
	<script src="Libraries/PropertyEditor.js"></script>
	<script src="Libraries/Controls.js"></script>
	<script src="Libraries/Stage.js"></script>
	<script src="Libraries/Javascript.js"></script>
	<script src="Libraries/Math.js"></script>
	
	<!-- Someone Else's Stuff -->
	<script src="Libraries/three.min.js"></script>
	<script src="Libraries/BufferGeometryUtils.js"></script>
	<script src="Libraries/OrbitControls.js"></script>
	<script src="Libraries/WebVR.js"></script>
	<script src="Libraries/threex.dynamictexture.js"></script>
	<script src="Libraries/threex.dynamictext2dobject.js"></script>
	
	<style>
		
		@font-face {
			font-family: UbuntuMono;
			src: url("Fonts/UbuntuMono-R.ttf")
		}
		
		@font-face {
			font-family: Rosario;
			src: url("Fonts/Rosario-Regular.ttf")
		}
		
		#loading {
			font-family: Rosario;
			position: absolute;
			left: 50vw;
			transform: translateX(-50%);
			top: 25vh;
			text-align:center;
		}
		
		#loading img {
			width: 100px;
		}
		
		pre {
			tab-size: 4;
		}
		
		body {
			font-family: Rosario;
			margin: 20px;
			background-color: rgb(23, 29, 40);
			color: rgb(224, 224, 224);
		}
		
		pre {
			font-family: UbuntuMono;
		}
		
		article {
			font-size: 18px;
		}
		
		.demo {
			max-width: 250px;
			width: 35vw;
			max-height: 200px;
			height: 35vw;
			display: inline-block;
		}
		
		#canvasContainer {
			position: absolute;
			left: 0;
			top: 0;
			width: 100vw;
			height: 100vh;
			display: block;
			z-index: -1;
		}
	
	</style>
</head>

<body>

	<canvas id="canvasContainer"></canvas>
	<header>
		<h1>Sandboy Symmetries</h1>
	</header>
	<main>
	
		<article>

<h1>Intro</h1>
In TodeSplat, you draw 2D diagrams to program elements.<br>
For example:
<pre>
	rule {
		@_ => _@
	}
</pre>
This makes an atom move to the right each tick.<br>
Let's represent the left-hand-side of our 2D diagram like this:<br>

<div id="rightGroup">
<div class="demo" id="right"></div>
</div>

<h1>Left and Right</h1>
Now let's imagine you want this atom to randomly move left or right.<br>
You can add the 'x' rule label, that flips the x-axis randomly:
<pre>
	rule x {
		@_ => _@
	}
</pre>
This means that one of two diagrams will be chosen:<br>

<div id="rightLeft">
<div class="demo" id="rightLeft0"></div>
<div class="demo" id="rightLeft1"></div>
</div>
With this 'x' label, there are only two translations:
<pre>
( x, y, 0 )
(-x, y, 0 )
</pre>
<br>
<h1>Sideways</h1>
You could also use the 'xz' label to make it go in any direction sideways:
<pre>
rule xz {
	@_ => _@
}
</pre>
<div id="side">
<div class="demo" id="side0"></div>
<div class="demo" id="side1"></div>
<div class="demo" id="side2"></div>
<div class="demo" id="side3"></div>
</div>
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
</pre>
<br>
<h1>Any Direction</h1>
You can use the 'xyz' label to make it go in ANY direction:
<pre>
rule xz {
	@_ => _@
}
</pre>
<div id="any">
	<div class="demo" id="any0"></div>
	<div class="demo" id="any1"></div>
	<div class="demo" id="any2"></div>
	<div class="demo" id="any3"></div>
	<div class="demo" id="any4"></div>
	<div class="demo" id="any5"></div>
</div>
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
( y, x, 0 )
( y,-x, 0 )
</pre>


		</article>
	
	</main>

	<!-- Structure -->
	<!--<script src="Source/Universe.js"></script>-->
	<script src="Source/World.js"></script>
	<script src="Source/Space.js"></script>
	<script src="Source/Site.js"></script>
	<script src="Source/Atom.js"></script>
	<script src="Source/Element.js"></script>
	<script src="Source/Rule.js"></script>
	<script src="Source/Event.js"></script>
	<script src="Source/Character.js"></script>
	
	<!-- Helpers -->
	<script src="Source/Symmetry.js"></script>
	<script src="Source/EventWindow.js"></script>
	<script src="Source/Behave.js"></script>
	<script src="Source/Random.js"></script>
	<script src="Source/TodeSplat.js"></script>
	
	<!-- Entities -->
	<!--<script src="Source/Dropper.js"></script>-->
	<script src="Source/Floor.js"></script>
	<script src="Source/Lighting.js"></script>
	
	<!-- Elements -->
	<script src="Elements/Globals.js"></script>
	<script src="Elements/Simple.js"></script>
	<!--<script src="Elements/Presets.js"></script>
	<script src="Elements/Sandbox.js"></script>
	<script src="Elements/Weather.js"></script>
	<script src="Elements/Explosive.js"></script>
	<script src="Elements/Life.js"></script>
	<script src="Elements/T2Tile.js"></script>-->
	<!--<script src="Elements/Tutorial.js"></script>-->
	
	<!-- Main -->
	<script>
		
		TodeSplat `
			element Dummy {
				rule {
					@_ => _@
				}
				
				rule {
					_@ => @_
				}
				
				rule side {
					_@ => @_
				}
				
				rule side {
					@_ => _@
				}
				
				rule {
					_ => @
					@    _
				}
				
				rule {
					@ => _
					_    @
				}
			}
		`
		
		const boxGeometry = new THREE.BoxGeometry(1, 1, 1)
		const boxLabelGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01)
	
		const makeBox = (character, colour, emissive = colour) => {
		
			const size = 32
		
			const dynamicTexture = new THREEx.DynamicTexture(size, size)
			dynamicTexture.context.font	= `${size * 3/4}px UbuntuMono`;
			dynamicTexture.clear(emissive)
			dynamicTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
			dynamicTexture.drawText(character, (size * 1/4)+(size*1/8)/2, (size*3/4)-(size*1/8)/2, "rgb(23, 29, 40)")
			
			const alphaTexture = new THREEx.DynamicTexture(size, size)
			alphaTexture.context.font	= `${size * 3/4}px UbuntuMono`;
			alphaTexture.clear("black")
			alphaTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
			alphaTexture.drawText(character, (size * 1/4)+(size*1/8)/2, (size*3/4)-(size*1/8)/2, "white")
			
			const dynamicMaterial = new THREE.MeshBasicMaterial({
				map: dynamicTexture.texture,
				alphaMap: alphaTexture.texture,
				alphaTest: 0.5,
			})
			
			const boxLabel = new THREE.Mesh(boxLabelGeometry, dynamicMaterial)
			/*const boxLabel = new THREEx.DynamicText2DObject(character)
			boxLabel.dynamicTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
			*/
		
			const boxMaterial = new THREE.MeshStandardMaterial({color: colour, emissive})
			const box = new THREE.Mesh(boxGeometry, boxMaterial)
			return {box, boxLabel}
		}
		
		const getColours = (character) => {
			if (character == "@") return ["#ffcc00", "#ffa34d"]
			return ["grey"]
		}
		
		let dummyCamera = undefined
		
		const canvas = $("#canvasContainer")
		const renderer = new THREE.WebGLRenderer({canvas, alpha: true, antialias: true, powerPreference: "high-performance"})
		
		const sceneElements = []
		const addScene = (elem, fn) => {
			sceneElements.push({elem, fn})
		}
		
		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
				renderer.setSize(width, height, false);
			}
			return needResize;
		}
		
		const clearColor = new THREE.Color('#000')
		
		const render = (time) => {
			time *= 0.001
			resizeRendererToDisplaySize(renderer)
			renderer.setScissorTest(false)
			renderer.setClearColor(clearColor, 0)
			renderer.clear(true, true)
			renderer.setScissorTest(true)
			
			const transform = `translateY(${window.scrollY}px)`
			renderer.domElement.style.transform = transform
			
			for (const {elem, fn} of sceneElements) {
				const rect = elem.getBoundingClientRect()
				const {left, right, top, bottom, width, height} = rect
				
				const isOffscreen = 
					bottom < 0 ||
					top > renderer.domElement.clientHeight ||
					right < 0 ||
					left > renderer.domElement.clientWidth
					
				if (!isOffscreen) {
					const positiveYUpBottom = renderer.domElement.clientHeight - bottom
					renderer.setScissor(left, positiveYUpBottom, width, height)
					renderer.setViewport(left, positiveYUpBottom, width, height)
					
					fn(time, rect)
				}
				
			}
			
			requestAnimationFrame(render)
		}
		
		const makeDemo = (name, group, rule, bothSides = false) => {
			
			const scene = new THREE.Scene()
			
			const fov = 30
			const camera = new THREE.PerspectiveCamera(fov)
			camera.position.set(0, 2, 10)
			camera.lookAt(0, 0, 0)
			
			/*{
				const color = 0xFFFFFF;
				const intensity = 1;
				const light = new THREE.DirectionalLight(color, intensity);
				light.position.set(-1, 2, 4);
				scene.add(light);
			}*/
			
			const sun = makeSun()
			//sun.position.set(200, 400, 400)
			scene.add(sun)
			
			const elem = $(`#${name}`)
			
			for (const event of rule) {
				const colours = getColours(event.input.name)
				const {box, boxLabel} = makeBox(event.input.name, ...colours)
				const position = SITE_POSITIONS[event.siteNumber]
				box.position.set(...position)
				boxLabel.position.set(...position)
				//boxLabel.position.set(position[0], position[1], position[2] + 0.51)
				scene.add(box)
				scene.add(boxLabel)				
			}
			
			let orbit = undefined
			if (true || !dummyCamera) {
				orbit = new THREE.OrbitControls(camera, $(`#${group}`))
				orbit.mouseButtons.RIGHT = THREE.MOUSE.ROTATE
				orbit.enableKeys = false
				orbit.enableDamping = true
				orbit.enableZoom = false
				orbit.touches = {
					ONE: THREE.TOUCH.ROTATE,
				}
				//stage.on.process(orbit.o.update)
				dummyCamera = camera
			}
			else {
				/*stage.on.process(() => {
					stage.camera.position.set(...dummyCamera.position)
					stage.camera.lookAt(0, 0, 0)
				})*/
			}
			
			addScene(elem, (time, rect) => {
				camera.aspect = rect.width / rect.height
				camera.updateProjectionMatrix()
				orbit.update()
				renderer.render(scene, camera)
			})
			
		}
		
		const getBaseRule = (ruleNumber) => Dummy.rules[ruleNumber].reflections[0][0]
		
		makeDemo("right", "rightGroup", getBaseRule(0))
		makeDemo("rightLeft0", "rightLeft", getBaseRule(0))
		makeDemo("rightLeft1", "rightLeft", getBaseRule(1))
		makeDemo("side0", "side", getBaseRule(0))
		makeDemo("side1", "side", getBaseRule(1))
		makeDemo("side2", "side", getBaseRule(2))
		makeDemo("side3", "side", getBaseRule(3))
		makeDemo("any0", "any", getBaseRule(0))
		makeDemo("any1", "any", getBaseRule(1))
		makeDemo("any2", "any", getBaseRule(2))
		makeDemo("any3", "any", getBaseRule(3))
		makeDemo("any4", "any", getBaseRule(4))
		makeDemo("any5", "any", getBaseRule(5))
		
		requestAnimationFrame(render)
		
	</script>
	
</body>
