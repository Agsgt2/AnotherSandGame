<!DOCTYPE html>
<head>
	<title>Sandboy Symmetries</title>
	<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0">
	
	<!-- My Stuff -->
	<script src="Libraries/Array.js"></script>
	<script src="Libraries/Async.js"></script>
	<script src="Libraries/Console.js"></script>
	<script src="Libraries/Bracketless.js"></script>
	<script src="Libraries/Document.js"></script>
	<script src="Libraries/Loop.js"></script>
	<script src="Libraries/Match.js"></script>
	<script src="Libraries/Report.js"></script>
	<script src="Libraries/Type.js"></script>
	<script src="Libraries/Event.js"></script>
	<script src="Libraries/Worker.js"></script>
	<script src="Libraries/Vector.js"></script>
	<script src="Libraries/PropertyEditor.js"></script>
	<script src="Libraries/Controls.js"></script>
	<script src="Libraries/Stage.js"></script>
	<script src="Libraries/Javascript.js"></script>
	<script src="Libraries/Math.js"></script>
	
	<!-- Someone Else's Stuff -->
	<script src="Libraries/three.min.js"></script>
	<script src="Libraries/BufferGeometryUtils.js"></script>
	<script src="Libraries/OrbitControls.js"></script>
	<script src="Libraries/WebVR.js"></script>
	
	<style>
		
		@font-face {
			font-family: UbuntuMono;
			src: url("Fonts/UbuntuMono-R.ttf")
		}
		
		@font-face {
			font-family: Rosario;
			src: url("Fonts/Rosario-Regular.ttf")
		}
		
		#loading {
			font-family: Rosario;
			position: absolute;
			left: 50vw;
			transform: translateX(-50%);
			top: 25vh;
			text-align:center;
		}
		
		#loading img {
			width: 100px;
		}
		
		pre {
			tab-size: 4;
		}
		
		body {
			font-family: Rosario;
			margin: 20px;
			background-color: rgb(23, 29, 40);
			color: rgb(224, 224, 224);
		}
		
		pre {
			font-family: UbuntuMono;
		}
		
		article {
			font-size: 18px;
		}
		
		.demo {
			width: 250px;
			height: 200px;
			display: inline-block;
		}
		
		#canvasContainer {
			position: absolute;
			left: 0;
			top: 0;
			width: 100vw;
			height: 100vh;
			display: block;
			z-index: -1;
		}
	
	</style>
</head>

<body>

	<canvas id="canvasContainer"></canvas>
	<header>
		<h1>Sandboy Symmetries</h1>
	</header>
	<main>
	
		<article>

<h1>Intro</h1>
In TodeSplat, you draw 2D diagrams to program elements.<br>
For example:
<pre>
	rule {
		@_ => _@
	}
</pre>
This makes an atom move to the right each tick.<br>
Let's represent the left-hand-side of our 2D diagram like this:<br>
<div class="demo" id="right"></div>

<h1>Left and Right</h1>
Now let's imagine you want this atom to randomly move left or right.<br>
You can add the 'x' rule label, that flips the x-axis randomly:
<pre>
	rule x {
		@_ => _@
	}
</pre>
This means that one of two diagrams will be chosen:<br>
<div class="demo" id="rightLeft0"></div>
<div class="demo" id="rightLeft1"></div><br>
With this 'x' label, there are only two translations:
<pre>
( x, y, z )
(-x, y, z )
</pre>
<br>
<h1>Sideways</h1>
You could also use the 'xz' label to make it go in every direction sideways:
<pre>
	rule xz {
		@_ => _@
	}
</pre>
<div class="demo" id="side0"></div>
<div class="demo" id="side1"></div>
<div class="demo" id="side2"></div>
<div class="demo" id="side3"></div>
<pre>
( x, y, z )
(-x, y, z )
( z, y, x )
( z, y,-x )
</pre>
<br>
			
			<h1>Any Direction</h1>
			You could use the 'xyz' label to make it go in any direction:
<pre>
	rule xyz {
		@_ => _@
	}
</pre>
			<div class="demo" id="any0"></div>
			<div class="demo" id="any1"></div>
			<div class="demo" id="any2"></div>
			<div class="demo" id="any3"></div>
			<div class="demo" id="any4"></div>
			<div class="demo" id="any5"></div>
<pre>
( x, y, z )
(-x, y, z )
( z, y, x )
( z, y,-x )
( y, x, z )
( y,-x, z )
</pre>
		</article>
	
	</main>

	<!-- Structure -->
	<!--<script src="Source/Universe.js"></script>-->
	<script src="Source/World.js"></script>
	<script src="Source/Space.js"></script>
	<script src="Source/Site.js"></script>
	<script src="Source/Atom.js"></script>
	<script src="Source/Element.js"></script>
	<script src="Source/Rule.js"></script>
	<script src="Source/Event.js"></script>
	<script src="Source/Character.js"></script>
	
	<!-- Helpers -->
	<script src="Source/Symmetry.js"></script>
	<script src="Source/EventWindow.js"></script>
	<script src="Source/Behave.js"></script>
	<script src="Source/Random.js"></script>
	<script src="Source/TodeSplat.js"></script>
	
	<!-- Entities -->
	<!--<script src="Source/Dropper.js"></script>-->
	<script src="Source/Floor.js"></script>
	<script src="Source/Lighting.js"></script>
	
	<!-- Elements -->
	<script src="Elements/Globals.js"></script>
	<script src="Elements/Simple.js"></script>
	<!--<script src="Elements/Presets.js"></script>
	<script src="Elements/Sandbox.js"></script>
	<script src="Elements/Weather.js"></script>
	<script src="Elements/Explosive.js"></script>
	<script src="Elements/Life.js"></script>
	<script src="Elements/T2Tile.js"></script>-->
	<!--<script src="Elements/Tutorial.js"></script>-->
	
	<!-- Main -->
	<script>
		
		TodeSplat `
			element Dummy {
				rule {
					@_ => _@
				}
				
				rule {
					_@ => @_
				}
				
				rule side {
					@_ => _@
				}
				
				rule side {
					_@ => @_
				}

				rule {
					_ => @
					@    _
				}

				rule {
					@ => _
					_    @
				}
			}
		`
		
		const boxGeometry = new THREE.BoxGeometry(1, 1, 1)
	
		const makeBox = (colour, emissive = colour) => {
			const boxMaterial = new THREE.MeshStandardMaterial({color: colour, emissive})
			const box = new THREE.Mesh(boxGeometry, boxMaterial)
			return box
		}
		
		const getColours = (character) => {
			if (character == "@") return ["#ffcc00", "#ffa34d"]
			return ["grey"]
		}
		
		let dummyCamera = undefined
		
		const canvas = $("#canvasContainer")
		const renderer = new THREE.WebGLRenderer({canvas, alpha: true, antialias: true, powerPreference: "high-performance"})
		
		const sceneElements = []
		const addScene = (elem, fn) => {
			sceneElements.push({elem, fn})
		}
		
		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
				renderer.setSize(width, height, false);
			}
			return needResize;
		}
		
		const clearColor = new THREE.Color('#000')
		
		const render = (time) => {
			time *= 0.001
			resizeRendererToDisplaySize(renderer)
			renderer.setScissorTest(false)
			renderer.setClearColor(clearColor, 0)
			renderer.clear(true, true)
			renderer.setScissorTest(true)
			
			const transform = `translateY(${window.scrollY}px)`
			renderer.domElement.style.transform = transform
			
			for (const {elem, fn} of sceneElements) {
				const rect = elem.getBoundingClientRect()
				const {left, right, top, bottom, width, height} = rect
				
				const isOffscreen = 
					bottom < 0 ||
					top > renderer.domElement.clientHeight ||
					right < 0 ||
					left > renderer.domElement.clientWidth
					
				if (!isOffscreen) {
					const positiveYUpBottom = renderer.domElement.clientHeight - bottom
					renderer.setScissor(left, positiveYUpBottom, width, height)
					renderer.setViewport(left, positiveYUpBottom, width, height)
					
					fn(time, rect)
				}
				
			}
			
			requestAnimationFrame(render)
		}
		
		const makeDemo = (name, rule, bothSides = false) => {
			
			const scene = new THREE.Scene()
			
			const fov = 30
			const camera = new THREE.PerspectiveCamera(fov)
			camera.position.set(0, 2, 10)
			camera.lookAt(0, 0, 0)
			
			/*{
				const color = 0xFFFFFF;
				const intensity = 1;
				const light = new THREE.DirectionalLight(color, intensity);
				light.position.set(-1, 2, 4);
				scene.add(light);
			}*/
			
			const sun = makeSun()
			//sun.position.set(200, 400, 400)
			scene.add(sun)
			
			const elem = $(`#${name}`)
			
			for (const event of rule) {
				const colours = getColours(event.input.name)
				const box = makeBox(...colours)
				const position = SITE_POSITIONS[event.siteNumber]
				box.position.set(...position)
				scene.add(box)
			}
			
			let orbit = undefined
			if (true || !dummyCamera) {
				orbit = new THREE.OrbitControls(camera)
				orbit.mouseButtons.RIGHT = THREE.MOUSE.ROTATE
				orbit.enableKeys = false
				orbit.enableDamping = true
				orbit.enableZoom = false
				orbit.touches = {
					ONE: undefined,
					TWO: THREE.TOUCH.DOLLY_ROTATE,
				}
				//stage.on.process(orbit.o.update)
				dummyCamera = camera
			}
			else {
				/*stage.on.process(() => {
					stage.camera.position.set(...dummyCamera.position)
					stage.camera.lookAt(0, 0, 0)
				})*/
			}
			
			addScene(elem, (time, rect) => {
				camera.aspect = rect.width / rect.height
				camera.updateProjectionMatrix()
				orbit.update()
				renderer.render(scene, camera)
			})
			
		}
		
		const getBaseRule = (ruleNumber) => Dummy.rules[ruleNumber].reflections[0][0]
		
		makeDemo("right", getBaseRule(0))
		makeDemo("rightLeft0", getBaseRule(0))
		makeDemo("rightLeft1", getBaseRule(1))
		makeDemo("side0", getBaseRule(0))
		makeDemo("side1", getBaseRule(1))
		makeDemo("side2", getBaseRule(2))
		makeDemo("side3", getBaseRule(3))
		makeDemo("any0", getBaseRule(0))
		makeDemo("any1", getBaseRule(1))
		makeDemo("any2", getBaseRule(2))
		makeDemo("any3", getBaseRule(3))
		makeDemo("any4", getBaseRule(4))
		makeDemo("any5", getBaseRule(5))
		
		requestAnimationFrame(render)
		
	</script>
	
</body>
