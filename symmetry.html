<!DOCTYPE html>
<head>
	<title>Sandboy Symmetries</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0">

	<!-- My Stuff -->
	<script src="Libraries/Array.js"></script>
	<script src="Libraries/Async.js"></script>
	<script src="Libraries/Console.js"></script>
	<script src="Libraries/Bracketless.js"></script>
	<script src="Libraries/Document.js"></script>
	<script src="Libraries/Loop.js"></script>
	<script src="Libraries/Match.js"></script>
	<script src="Libraries/Report.js"></script>
	<script src="Libraries/Type.js"></script>
	<script src="Libraries/Event.js"></script>
	<script src="Libraries/Worker.js"></script>
	<script src="Libraries/Vector.js"></script>
	<script src="Libraries/PropertyEditor.js"></script>
	<script src="Libraries/Controls.js"></script>
	<script src="Libraries/Stage.js"></script>
	<script src="Libraries/Javascript.js"></script>
	<script src="Libraries/Math.js"></script>
	
	<!-- Someone Else's Stuff -->
	<script src="Libraries/three.min.js"></script>
	<script src="Libraries/BufferGeometryUtils.js"></script>
	<script src="Libraries/OrbitControls.js"></script>
	<script src="Libraries/WebVR.js"></script>
	<script src="Libraries/threex.dynamictexture.js"></script>
	<script src="Libraries/threex.dynamictext2dobject.js"></script>
	
	<style>
		
		@font-face {
			font-family: UbuntuMono;
			src: url("Fonts/UbuntuMono-R.ttf")
		}
		
		@font-face {
			font-family: Rosario;
			src: url("Fonts/Rosario-Regular.ttf")
		}
		
		#loading {
			font-family: Rosario;
			position: absolute;
			left: 50vw;
			transform: translateX(-50%);
			top: 25vh;
			text-align:center;
		}
		
		#loading img {
			width: 100px;
		}
		
		pre {
			tab-size: 4;
		}
		
		body {
			font-family: Rosario;
			margin: 20px;
			background-color: rgb(23, 29, 40);
			color: rgb(224, 224, 224);
		}
		
		pre {
			font-family: UbuntuMono;
		}
		
		article {
			font-size: 18px;
		}
		
		.demo {
			max-width: 200px;
			width: 30vw;
			max-height: 200px;
			height: 35vw;
			display: inline-block;
		}
		
		#canvasContainer {
			position: absolute;
			left: 0;
			top: 0;
			width: 100%;
			height: 100vh;
			display: block;
			z-index: -1;
			margin: 0;
			padding: 0;
		}
	
	</style>
</head>

<body>

	<canvas id="canvasContainer"></canvas>
	<header>
		<h1>Sandboy Symmetries</h1>
	</header>
	<main>
	
		<article>

<h1>Intro</h1>
In TodeSplat, you draw 2D diagrams to program elements.<br>
For example:
<pre>
rule {
	@_ => _@
}
</pre>
This makes an atom move to the right each tick.<br>
Let's represent the left-hand-side of our 2D diagram like this:<br>

<div id="rightGroup">
<div class="demo" id="right"></div>
</div>

<h1>Left and Right</h1>
Now let's imagine you want this atom to randomly move left or right.<br>
You can write 'x', which flips the x-axis randomly:
<pre>
rule x {
	@_ => _@
}
</pre>
This means that one of two diagrams will be chosen:<br>

<div id="rightLeft">
<div class="demo" id="rightLeft0"></div>
<div class="demo" id="rightLeft1"></div>
</div>
When you write the 'x' label, you are saying, "I don't care which way round the x-axis is."<br>
With this 'x' label, there are only two translations:
<pre>
( x, y, 0 )
(-x, y, 0 )
</pre>
<br>
<h1>Sideways</h1>
You could also use the 'xz' label to make it go in any direction sideways:
<pre>
rule xz {
	@_ => _@
}
</pre>
<div id="side">
<div class="demo" id="side0"></div>
<div class="demo" id="side1"></div>
<div class="demo" id="side2"></div>
<div class="demo" id="side3"></div>
</div>
By writing 'xz', you are saying, "I don't care which way round the x-axis or z-axis are."
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
</pre>
<br>
<h1>Any Direction</h1>
You can use the 'xyz' label to make it go in ANY direction:
<pre>
rule xyz {
	@_ => _@
}
</pre>
<div id="any">
	<div class="demo" id="any0"></div>
	<div class="demo" id="any1"></div>
	<div class="demo" id="any2"></div>
	<div class="demo" id="any3"></div>
	<div class="demo" id="any4"></div>
	<div class="demo" id="any5"></div>
</div>
By writing 'xyz', you are saying, "I don't care which way round the x, y, or z-axes are."<br>
In this case, there are 6 relevant transformations:
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
( y, x, 0 )
( y,-x, 0 )
</pre>
<br>
<h1>Slide Right</h1>
Let's look at a slightly more complicated example now:
<pre>
rule {
	@  => _
	#_    #@
}
</pre>
This makes an atom slide down and to the right if there is an atom below it.<br>
<div id="slideRight">
	<div class="demo" id="slideRight0"></div>
</div>
<h1>Slide Sideways</h1>
Again, we can use a symmetry label to make it randomly choose a certain direction sideways:
<pre>
rule xz {
	@  => _
	#_    #@
}
</pre>
<div id="slideSide">
	<div class="demo" id="slideSide0"></div>
	<div class="demo" id="slideSide1"></div>
	<div class="demo" id="slideSide2"></div>
	<div class="demo" id="slideSide3"></div>
</div>
<pre>
( x, y, 0 )
(-x, y, 0 )
( 0, y, x )
( 0, y,-x )
</pre><br>
<h1>Slide Anywhere</h1>
What about sliding in any direction?
<pre>
rule xyz {
	@  => _
	#_    #@
}
</pre>
I find it trickier to visualise all possibilities for this one.<br>
I think these are all the possible transformations:
<pre>
( x, y, 0 )    ( x, 0, y )
( x,-y, 0 )    ( x, 0,-y )
(-x, y, 0 )    (-x, 0, y )
(-x,-y, 0 )    (-x, 0,-y )

( 0, y, x )    ( y, x, 0 )
( 0,-y, x )    (-y, x, 0 )
( 0, y,-x )    ( y,-x, 0 )
( 0,-y,-x )    (-y,-x, 0 )

( 0, x, y )    ( y, 0, x )
( 0, x,-y )    (-y, 0, x )
( 0,-x, y )    ( y, 0,-x )
( 0,-x,-y )    (-y, 0,-x )

</pre>
And this is what they look like in 3D (not necessarily in order):
<div id="slideAny">
	<div class="demo" id="slideAny0"></div>
	<div class="demo" id="slideAny1"></div>
	<div class="demo" id="slideAny2"></div>
	<div class="demo" id="slideAny3"></div>
	<div class="demo" id="slideAny4"></div>
	<div class="demo" id="slideAny5"></div>
	<div class="demo" id="slideAny6"></div>
	<div class="demo" id="slideAny7"></div>
	<div class="demo" id="slideAny8"></div>
	<div class="demo" id="slideAny9"></div>
	<div class="demo" id="slideAny10"></div>
	<div class="demo" id="slideAny11"></div>
	<div class="demo" id="slideAny12"></div>
	<div class="demo" id="slideAny13"></div>
	<div class="demo" id="slideAny14"></div>
	<div class="demo" id="slideAny15"></div>
	<div class="demo" id="slideAny16"></div>
	<div class="demo" id="slideAny17"></div>
	<div class="demo" id="slideAny18"></div>
	<div class="demo" id="slideAny19"></div>
	<div class="demo" id="slideAny20"></div>
	<div class="demo" id="slideAny21"></div>
	<div class="demo" id="slideAny22"></div>
	<div class="demo" id="slideAny23"></div>
</div>

<h1>Follow Through</h1>
During an event, only one symmetry is selected, even for multiple rules.<br>
In the following code, the second rule will NEVER be reached:
<pre>
element Foo {
	
	rule x {
		@_ => _@
	}
	
	rule x {
		@_ => _@
		#     #
	}
}
</pre>
For all rules, the x-axis is either (1) flipped, or (2) not flipped.<br>
It is not flipped on a per-rule basis.<br>
So the potential diagrams are either these:<br>
<div id="follow">
	<div class="demo" id="follow0"></div>
	<div class="demo" id="follow1"></div>
</div>
	Or these:
<div id="followOther">
	<div class="demo" id="follow2"></div>
	<div class="demo" id="follow3"></div>
</div>

<h1 id="diffo">Follow Through - Different Symmetries</h1>
The chosen symmetry follows through even when rules have different symmetry labels.<br>
ie: Where applicable, a chosen symmetry will stay consistent from one rule to the next.<br>
Look at this:
<pre>
element Foo {
	
	rule xz {
		@_ => _@
	}
	
	rule x {
		@_ => _@
		#     #
	}
}
</pre>
When the first rule points to the right, the second rule points right too:
<div id="diffoRight">
	<div class="demo" id="diffoRight0"></div>
	<div class="demo" id="diffoRight1"></div>
</div>
When the first rule points to the left, the second rule points left too:
<div id="diffoLeft">
	<div class="demo" id="diffoLeft0"></div>
	<div class="demo" id="diffoLeft1"></div>
</div>
But sometimes the first rule points along the z-axis.<br>
In these cases, it wouldn't make much sense to try to match this to the second rule.<br>
When this happens, the second rule randomly picks one of its translations.<br>
For example, you could have this combination:
<div id="diffoZ">
	<div class="demo" id="diffoZ0"></div>
	<div class="demo" id="diffoZ1"></div>
</div>
For completeness, let's now list all possibile combinations of these rules:
Note: Some rules have more chance of happening than others.
<div id="diffoAll">
	<div class="demo" id="diffoAll0"></div>
	<div class="demo" id="diffoAll1"></div>
	<p style="width: 70vw; max-width: 400px; text-align: center;">--- or ---</p>
	<div class="demo" id="diffoAll2"></div>
	<div class="demo" id="diffoAll3"></div>
	<p style="width: 70vw; max-width: 400px; text-align: center;">--- or ---</p>
	<div class="demo" id="diffoAll4"></div>
	<div class="demo" id="diffoAll5"></div>
	<p style="width: 70vw; max-width: 400px; text-align: center;">--- or ---</p>
	<div class="demo" id="diffoAll6"></div>
	<div class="demo" id="diffoAll7"></div>
	<p style="width: 70vw; max-width: 400px; text-align: center;">--- or ---</p>
	<div class="demo" id="diffoAll8"></div>
	<div class="demo" id="diffoAll9"></div>
	<p style="width: 70vw; max-width: 400px; text-align: center;">--- or ---</p>
	<div class="demo" id="diffoAll10"></div>
	<div class="demo" id="diffoAll11"></div>
	
</div>



		</article>
	
	</main>

	<!-- Structure -->
	<!--<script src="Source/Universe.js"></script>-->
	<script src="Source/World.js"></script>
	<script src="Source/Space.js"></script>
	<script src="Source/Site.js"></script>
	<script src="Source/Atom.js"></script>
	<script src="Source/Element.js"></script>
	<script src="Source/Rule.js"></script>
	<script src="Source/Event.js"></script>
	<script src="Source/Character.js"></script>
	
	<!-- Helpers -->
	<script src="Source/Symmetry.js"></script>
	<script src="Source/EventWindow.js"></script>
	<script src="Source/Behave.js"></script>
	<script src="Source/Random.js"></script>
	<script src="Source/TodeSplat.js"></script>
	
	<!-- Entities -->
	<!--<script src="Source/Dropper.js"></script>-->
	<script src="Source/Floor.js"></script>
	<script src="Source/Lighting.js"></script>
	
	<!-- Elements -->
	<script src="Elements/Globals.js"></script>
	<script src="Elements/Simple.js"></script>
	<!--<script src="Elements/Presets.js"></script>
	<script src="Elements/Sandbox.js"></script>
	<script src="Elements/Weather.js"></script>
	<script src="Elements/Explosive.js"></script>
	<script src="Elements/Life.js"></script>
	<script src="Elements/T2Tile.js"></script>-->
	<!--<script src="Elements/Tutorial.js"></script>-->
	
	<!-- Main -->
	<script>
		
		document.fonts.ready.then(() => {
			const boxGeometry = new THREE.BoxGeometry(1, 1, 1)
			const boxLabelGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01)
		
			const makeBox = (character, colour, emissive = colour) => {
			
				const size = 32
			
				const dynamicTexture = new THREEx.DynamicTexture(size, size)
				dynamicTexture.context.font	= `${size * 3/4}px UbuntuMono`;
				dynamicTexture.clear(emissive)
				dynamicTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
				dynamicTexture.drawText(character, (size * 1/4)+(size*1/8)/2, (size*3/4)-(size*1/8)/2, "rgb(23, 29, 40)")
				
				const alphaTexture = new THREEx.DynamicTexture(size, size)
				alphaTexture.context.font	= `${size * 3/4}px UbuntuMono`;
				alphaTexture.clear("black")
				alphaTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
				alphaTexture.drawText(character, (size * 1/4)+(size*1/8)/2, (size*3/4)-(size*1/8)/2, "white")
				
				const dynamicMaterial = new THREE.MeshBasicMaterial({
					map: dynamicTexture.texture,
					alphaMap: alphaTexture.texture,
					alphaTest: 0.5,
				})
				
				const boxLabel = new THREE.Mesh(boxLabelGeometry, dynamicMaterial)
				/*const boxLabel = new THREEx.DynamicText2DObject(character)
				boxLabel.dynamicTexture.texture.anisotropy = renderer.capabilities.getMaxAnisotropy()
				*/
			
				const boxMaterial = new THREE.MeshStandardMaterial({color: colour, emissive})
				const box = new THREE.Mesh(boxGeometry, boxMaterial)
				return {box, boxLabel}
			}
			
			const getColours = (character) => {
				if (character == "@") return ["#ffcc00", "#ffa34d"]
				if (character == "#") return ["#4b5971"]
				if (character == "_") return ["grey"]
				return ["grey"]
			}
			
			let dummyCamera = undefined
			
			const canvas = $("#canvasContainer")
			const renderer = new THREE.WebGLRenderer({canvas, alpha: true, antialias: true, powerPreference: "high-performance"})
			
			const sceneElements = []
			const addScene = (elem, fn) => {
				sceneElements.push({elem, fn})
			}
			
			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}
			
			const clearColor = new THREE.Color('#000')
			
			const render = (time) => {
				time *= 0.001
				resizeRendererToDisplaySize(renderer)
				renderer.setScissorTest(false)
				renderer.setClearColor(clearColor, 0)
				renderer.clear(true, true)
				renderer.setScissorTest(true)
				
				const transform = `translateY(${window.scrollY}px)`
				renderer.domElement.style.transform = transform
				
				for (const {elem, fn} of sceneElements) {
					const rect = elem.getBoundingClientRect()
					const {left, right, top, bottom, width, height} = rect
					
					const isOffscreen = 
						bottom < 0 ||
						top > renderer.domElement.clientHeight ||
						right < 0 ||
						left > renderer.domElement.clientWidth
						
					if (!isOffscreen) {
						const positiveYUpBottom = renderer.domElement.clientHeight - bottom
						renderer.setScissor(left, positiveYUpBottom, width, height)
						renderer.setViewport(left, positiveYUpBottom, width, height)
						
						fn(time, rect)
					}
					
				}
				
				requestAnimationFrame(render)
			}
			
			const makeDemo = (name, group, rule, bothSides = false) => {
				
				const scene = new THREE.Scene()
				
				//const fov = 30
				const fov = 15
				const camera = new THREE.OrthographicCamera(-2.5, 2.5, 2.5, -2.5)
				//const camera = new THREE.PerspectiveCamera(fov)
				camera.position.set(-1, 2, 10)
				//camera.position.set(0, 3, 15)
				camera.lookAt(0, 0, 0)
				
				/*{
					const color = 0xFFFFFF;
					const intensity = 1;
					const light = new THREE.DirectionalLight(color, intensity);
					light.position.set(-1, 2, 4);
					scene.add(light);
				}*/
				
				const sun = makeSun()
				//sun.position.set(200, 400, 400)
				scene.add(sun)
				
				const elem = $(`#${name}`)
				
				if (elem == null) return
				if (rule == undefined) return
				
				for (const event of rule) {
					const colours = getColours(event.input.name)
					const {box, boxLabel} = makeBox(event.input.name, ...colours)
					const position = SITE_POSITIONS[event.siteNumber]
					box.position.set(...position)
					boxLabel.position.set(...position)
					//boxLabel.position.set(position[0], position[1], position[2] + 0.51)
					scene.add(box)
					scene.add(boxLabel)				
				}
				
				let orbit = undefined
				if (true || !dummyCamera) {
					orbit = new THREE.OrbitControls(camera, $(`#${group}`))
					orbit.mouseButtons.RIGHT = THREE.MOUSE.ROTATE
					orbit.mouseButtons.MIDDLE = undefined
					orbit.enableKeys = false
					orbit.enableDamping = true
					orbit.enableZoom = false
					orbit.touches = {
						ONE: THREE.TOUCH.ROTATE,
					}
					//stage.on.process(orbit.o.update)
					dummyCamera = camera
				}
				else {
					/*stage.on.process(() => {
						stage.camera.position.set(...dummyCamera.position)
						stage.camera.lookAt(0, 0, 0)
					})*/
				}
				
				addScene(elem, (time, rect) => {
					camera.aspect = rect.width / rect.height
					camera.updateProjectionMatrix()
					orbit.update()
					renderer.render(scene, camera)
				})
				
			}
					
			TodeSplat `
				element Dummy {
					rule {
						@_ => _@
					}
					
					rule {
						_@ => @_
					}
					
					rule side {
						_@ => @_
					}
					
					rule side {
						@_ => _@
					}
					
					rule {
						_ => @
						@    _
					}
					
					rule {
						@ => _
						_    @
					}
					
					// 6
					rule {
						@  => _
						#_    #@
					}
					
					rule {
						 @ =>  _
						_#    @#
					}
					
					rule side {
						 @ =>  _
						_#    @#
					}
					
					rule side {
						@  => _
						#_    #@
					}
					
					//10
					rule {
						#_    #@
						@  => _
					}
					
					rule top {
						#_    #@
						@  => _
					}
					
					rule top {
						@  => _
						#_    #@
					}
					
					//??
					rule {
						_#    @#
						 @ =>  _
					}
					
					rule {
						#@ => ..
						_     .
					}
					
					rule {
						 _     .
						@# => ..
					}
					
					//Reflected
					rule {
						_     @
						#@ => #_
					}
				}
			`
			
			const getBaseRule = (ruleNumber, element = Dummy) => element.rules[ruleNumber] && element.rules[ruleNumber].reflections[0][0]
			
			makeDemo("right", "rightGroup", getBaseRule(0))
			makeDemo("rightLeft0", "rightLeft", getBaseRule(0))
			makeDemo("rightLeft1", "rightLeft", getBaseRule(1))
			makeDemo("side0", "side", getBaseRule(0))
			makeDemo("side1", "side", getBaseRule(1))
			makeDemo("side2", "side", getBaseRule(2))
			makeDemo("side3", "side", getBaseRule(3))
			makeDemo("any0", "any", getBaseRule(0))
			makeDemo("any1", "any", getBaseRule(1))
			makeDemo("any2", "any", getBaseRule(2))
			makeDemo("any3", "any", getBaseRule(3))
			makeDemo("any4", "any", getBaseRule(4))
			makeDemo("any5", "any", getBaseRule(5))
			makeDemo("slideRight0", "slideRight", getBaseRule(6))
			makeDemo("slideSide0", "slideSide", getBaseRule(6))
			makeDemo("slideSide1", "slideSide", getBaseRule(7))
			makeDemo("slideSide2", "slideSide", getBaseRule(8))
			makeDemo("slideSide3", "slideSide", getBaseRule(9))
			
			TodeSplat `
				element SlideAny {
					
					// x y 0
					rule {
						@  => _
						#_    #@
					}
					
					rule {
						 @ =>  _
						_#    @#
					}
					
					rule {
						#_    #@
						@  => _
					}
					
					rule {
						_#    @#
						 @ =>  _
					}
					
					// x 0 y
					rule top {
						#_    #@
						@  => _
					}
					
					rule top {
						_#    @#
						 @ =>  _
					}
					
					rule top {
						@  => _
						#_    #@
					}
					
					rule top {
						 @ =>  _
						_#    @#
					}
					
					// 0 y x
					rule side {
						#_    #@
						@  => _
					}
					
					rule side {
						_#    @#
						 @ =>  _
					}
					
					rule side {
						@  => _
						#_    #@
					}
					
					rule side {
						 @ =>  _
						_#    @#
					}
					
					// y x 0
					rule {
						_  => .
						#@    ..
					}
					
					rule {
						 _ =>  _
						@#    @#
					}
					
					rule {
						#@    #@
						_  => _
					}
					
					rule {
						@#    @#
						 _ =>  _
					}
					
					// 0 x y
					rule side {
						 _ =>  .
						@#    ..
					}
					
					rule side {
						_  => .
						#@    ..
					}
					
					rule side {
						@#    ..
						 _ =>  .
					}
					
					rule side {
						#@    ..
						_  => .
					}
					
					// y 0 x
					rule top {
						#@ => ..
						_     .
					}
					
					rule top {
						@# => ..
						 _     .
					}
					
					rule top {
						_     .
						#@ => ..
					}
					
					rule top {
						 _     .
						@# => ..
					}
					
				}
			`
			
			makeDemo("slideAny0", "slideAny", getBaseRule(0, SlideAny))
			makeDemo("slideAny1", "slideAny", getBaseRule(1, SlideAny))
			makeDemo("slideAny2", "slideAny", getBaseRule(2, SlideAny))
			makeDemo("slideAny3", "slideAny", getBaseRule(3, SlideAny))
			makeDemo("slideAny4", "slideAny", getBaseRule(4, SlideAny))
			makeDemo("slideAny5", "slideAny", getBaseRule(5, SlideAny))
			makeDemo("slideAny6", "slideAny", getBaseRule(6, SlideAny))
			makeDemo("slideAny7", "slideAny", getBaseRule(7, SlideAny))
			makeDemo("slideAny8", "slideAny", getBaseRule(8, SlideAny))
			makeDemo("slideAny9", "slideAny", getBaseRule(9, SlideAny))
			makeDemo("slideAny10", "slideAny", getBaseRule(10, SlideAny))
			makeDemo("slideAny11", "slideAny", getBaseRule(11, SlideAny))
			makeDemo("slideAny12", "slideAny", getBaseRule(12, SlideAny))
			makeDemo("slideAny13", "slideAny", getBaseRule(13, SlideAny))
			makeDemo("slideAny14", "slideAny", getBaseRule(14, SlideAny))
			makeDemo("slideAny15", "slideAny", getBaseRule(15, SlideAny))
			makeDemo("slideAny16", "slideAny", getBaseRule(16, SlideAny))
			makeDemo("slideAny17", "slideAny", getBaseRule(17, SlideAny))
			makeDemo("slideAny18", "slideAny", getBaseRule(18, SlideAny))
			makeDemo("slideAny19", "slideAny", getBaseRule(19, SlideAny))
			makeDemo("slideAny20", "slideAny", getBaseRule(20, SlideAny))
			makeDemo("slideAny21", "slideAny", getBaseRule(21, SlideAny))
			makeDemo("slideAny22", "slideAny", getBaseRule(22, SlideAny))
			makeDemo("slideAny23", "slideAny", getBaseRule(23, SlideAny))
			
			TodeSplat `
				element FollowDummy {
					
					rule {
						@_ => _@
					}
					
					rule {
						_@ => @_
					}
					
					rule {
						@_ => _@
						#     #
					}
					
					rule {
						_@ => @_
						 #     #
					}
					
					rule side {
						_@ => @_
					}
					
					rule side {
						@_ => _@
					}
				}
			`
			
			makeDemo("follow0", "follow", getBaseRule(0, FollowDummy))
			makeDemo("follow1", "follow", getBaseRule(2, FollowDummy))
			
			makeDemo("follow2", "followOther", getBaseRule(1, FollowDummy))
			makeDemo("follow3", "followOther", getBaseRule(3, FollowDummy))
			
			makeDemo("diffoRight0", "diffoRight", getBaseRule(0, FollowDummy))
			makeDemo("diffoRight1", "diffoRight", getBaseRule(2, FollowDummy))
			
			makeDemo("diffoLeft0", "diffoLeft", getBaseRule(1, FollowDummy))
			makeDemo("diffoLeft1", "diffoLeft", getBaseRule(3, FollowDummy))
			
			makeDemo("diffoZ0", "diffoZ", getBaseRule(4, FollowDummy))
			makeDemo("diffoZ1", "diffoZ", getBaseRule(2, FollowDummy))
			
			makeDemo("diffoAll0", "diffoAll", getBaseRule(0, FollowDummy))
			makeDemo("diffoAll1", "diffoAll", getBaseRule(2, FollowDummy))
			makeDemo("diffoAll2", "diffoAll", getBaseRule(1, FollowDummy))
			makeDemo("diffoAll3", "diffoAll", getBaseRule(3, FollowDummy))
			makeDemo("diffoAll4", "diffoAll", getBaseRule(4, FollowDummy))
			makeDemo("diffoAll5", "diffoAll", getBaseRule(2, FollowDummy))
			makeDemo("diffoAll6", "diffoAll", getBaseRule(4, FollowDummy))
			makeDemo("diffoAll7", "diffoAll", getBaseRule(3, FollowDummy))
			
			makeDemo("diffoAll8", "diffoAll", getBaseRule(5, FollowDummy))
			makeDemo("diffoAll9", "diffoAll", getBaseRule(2, FollowDummy))
			makeDemo("diffoAll10", "diffoAll", getBaseRule(5, FollowDummy))
			makeDemo("diffoAll11", "diffoAll", getBaseRule(3, FollowDummy))
			
			requestAnimationFrame(render)
		})
		
	</script>
	
</body>
